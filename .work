#official exports:



#unofficial exports:
export CURRENT_RELEASE=rel-1.143
export LSB_MASTER=lsb/master
export LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE
export GIT_MERGE_AUTOEDIT=no

# This is only an issue if you usually extract std from stacks and upgrade has to process lot of std versions
# In that case, there might be out of memory problems while building java
export UPGRADE_MAX_MEMORY_GB=8


# Other variables
REVIEW_STATUS_PENDING="pending"
REVIEW_STATUS_APPROVED="approved"
REVIEW_STATUS_ANY="any"

# Git related functions
function gitskipworktree() {
  git update-index --skip-worktree "$1"
}

function gitunskipworktree() {
  git update-index --no-skip-worktree $1
}

function backupbranch() {
  currentbranch=$(git.getcurrentbranch)
  searchstring=pisoni
  replacestring=backup/pisoni
  separator=/
  curdate=$(system.getcurrentdate)
  newbranch="${currentbranch/$searchstring/$replacestring}/$curdate"
  echo $newbranch
  # create new backup branch
  git checkout -b $newbranch
  # go back to our branch
  git checkout $currentbranch
}

function fixDiskImagesJS() {
  diskImageUmountAll
  rm ~/build_tools/diskimage/onshape-javascript_*
  source buildenv.bash  
}

runupgrade() {
  gradle runDocumentUpgrade -Donshape.upgrade.exitwhenfinished=true
}

runretrieval() {
  gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true
}

function makelikeproduction() {
  mongobackup
  stopbelcad
  mongoDropAll
  mongoDropToProduction
  export SKIP_INTERNAL_MODULES=1
}

function makelikeproductionwithbuild() {
  makelikeproduction
  buildgradleparallel
}

function openconfigpropertiesjson() {
  sublime $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
}

function setupforproductionretrieval() {
  echo "setting SKIP_INTERNAL_MODULES to 1"
  export SKIP_INTERNAL_MODULES=1
  sublime $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
  echo "Change the defaultValue of productionretrieval.write-s3 from false to true in the opened config-properties.json"
  waitforenterkey "Press enter when done"
  echo "Build (gradle) manually now using buildgradleparallel"
  #buildgradleparallel
  #waitforenterkey "Press enter when done"
  echo "call runupgrade to run document upgrade"
  #runupgrade
  #waitforenterkey "Press enter when upgrade has been done"
  echo "You can now see upgrade logs in $STAGE/ModelingSvc/logs/btserver.log"
  echo "Also, the upgrade data should be written to $STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  #open "$STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  echo "Finally, run the local production retrieval process by calling runretrieval"
  #runretrieval
}

function waitforenterkey() {
  read -p "$1"
}

runjunittest() {
    gradle safelyRunSpecificTests -Dtest=$1
}

awsconfigure() {
  btAws configure --profile codebuild
}

myprecommit() {
  # Remove this first line once yarn precommit starts catching 
  # typescript errors again
  #npx tsc --noEmit --project $REPO_NEWTON/project/web/tsconfig.json
  checkTidy
  gradle :java:pmd
  #gradle :java:codeChecker
  grunt checkJsCode
}

addstaticroutetojumpbox() {
  sudo route -n add 54.187.217.158/32 $1
}

getnewbranchname() {
  inputbranchname=$1
  targetbranch=$2
  if ! (string.beginswith $inputbranchname "pisoni/")
  then
    inputbranchname=pisoni/$inputbranchname
  fi

  inputbranchname=$(string.simplereplace $inputbranchname "-lsb-*" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-master" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-release" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-rel-[1-9]*" "")
  targetbranch=$(string.simplereplace $targetbranch "/" "-")
  inputbranchname=$inputbranchname-$targetbranch

  echo $inputbranchname
}

function checkoutfromlatestmaster() {
  git checkout master
  git pull
  git checkout -b $(getnewbranchname $1 "master")
}

function checkoutfromrelease() {
  git checkout $CURRENT_RELEASE
  git pull
  git checkout -b $(getnewbranchname $1 $CURRENT_RELEASE)
}

function checkoutfromlsbbranch() {
  if string.isemptyorblank $1
  then
    echo "Please provide new branch name"
  elif string.isemptyorblank $2
  then
    echo "Please provide the base branch name"
  else
    gitBranchLsb $(getnewbranchname $1 "lsb/$2") $2
  fi
}

function checkoutfromlsbmaster() {
  checkoutfromlsbbranch "$1" "master" #lsb/ is eventually appended by gitBranchLsb
}

function checkoutfromlsbrelease() {
  checkoutfromlsbbranch "$1" "$CURRENT_RELEASE" #lsb/ is eventually appended by gitBranchLsb
}

rebaselatestlsbmaster() {
  pullmerge $LSB_MASTER --rebase
}

rebaselatestlsbrelease() {
  pullmerge $LSB_CURRENT_RELEASE --rebase
}

pulllatestlsbrelease() {
  pullmerge $LSB_CURRENT_RELEASE
}

rebaselatestrelease() {
  pullmerge $CURRENT_RELEASE --rebase
}

pulllatestrelease() {
  pullmerge $CURRENT_RELEASE
}

# Get the review request id associated with the current branch
function getcurrentreviewrequestid() {
  local statusString=$1

  # convert multiline rbt status output to single line
  local rbtstatus=$(rbt status | tr '\n' '\r')
  currentbranch=$(git.getcurrentbranch)

case $statusString in

  $REVIEW_STATUS_APPROVED)
    statusString='Ship It\!'
    ;;

  $REVIEW_STATUS_PENDING)
    statusString='Pending'
    ;;

  $REVIEW_STATUS_ANY)
    statusString=''
    ;;

  *)
    statusString=''
    ;;
esac


  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  local reviewrequestid=$(echo $rbtstatus | sed -En "s,.*$statusString[^|]+\| r\/([[:digit:]]+) [^|]+ \| $currentbranch \|.*,\1,p")

  # It'll be quite usual that we'd get an lsb/master or master based branch and want to merge in both.
  if string.endswith $currentbranch "-rel*"
  then
    local testbranch=$(getnewbranchname $currentbranch $LSB_MASTER)
    # Even if the lsb/master based branch is approved for this branch, then also we accept it as approved.
    reviewrequestid=$(echo $rbtstatus | sed -En "s,.*$statusString[^|]+\| r\/([[:digit:]]+) [^|]+ \| $testbranch \|.*,\1,p")
  fi

  echo $reviewrequestid
}

# Unless otherwise specified, default branch for rbt is master
function rbtupdate() {
  if string.isemptyorblank $1
  then
    reviewrequestid=$(getcurrentreviewrequestid $REVIEW_STATUS_ANY)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find a matching review request for the branch, enter manually."
    else
      echo "Automatically found review request id: $reviewrequestid for current branch"
      rbtupdate $reviewrequestid
    fi
  else
    echo "calling rbt post -u -r $1"
    rbt post -o -u -r $1
  fi
}

function rbtupdatewithrebase() {
  rebaselatestmaster
  rbtupdate
}

rbtpost() {
  rbt post -o
}

rbtpostwithrebase() {
  rebaselatestmaster
  rbtpost
}

rbtpostfromlsbmaster() {
  echo "Calling rbt post $LSB_MASTER...HEAD"
  rbt post -o $LSB_MASTER...HEAD
}

rbtpostfromlsbrelease() {
  echo "Calling rbt post $LSB_CURRENT_RELEASE...HEAD"
  rbt post -o $LSB_CURRENT_RELEASE...HEAD
}


rbtupdatefrombranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  elif string.isemptyorblank $2
  then
    reviewrequestid=$(getcurrentreviewrequestid $REVIEW_STATUS_ANY)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find a matching review request for the branch, enter manually."
    else
      echo "Automatically found review request id: $reviewrequestid for current branch"
      rbtupdatefrombranch $1 $reviewrequestid
    fi
  else
    echo "Calling rbt post -u -r $2 $1...HEAD"
    rbt post -o -u -r $2 $1...HEAD
  fi
}

rbtupdatefromlsbrelease() {
  rbtupdatefrombranch $LSB_CURRENT_RELEASE $1
}

rbtupdatefromlsbmaster() {
  rbtupdatefrombranch $LSB_MASTER $1
}

rbtupdatefromlsbreleasewithrebase() {
  rebaselatestlsbrelease
  rbtupdatefromlsbrelease
}

rbtupdatefromlsbmasterwithrebase() {
  rebaselatestlsbmaster
  rbtupdatefromlsbmaster
}

setupjumpboxcertificates() {
  export USERNAME=pisoni
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USERNAME.key /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USERNAME.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:ca.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:tls-auth.key /tmp  
}

restartbelcad() {
  stopbelcad
  startbelcad
}

beep() {
  tput bel
}

playfinishsound() {
  beep;beep;
  say "Build Complete"
}

buildgradleparallel() {
  gradle --parallel
  playfinishsound
}

# There's no reason to keep merged branches
# but we can keep for a few days just for reference purposes
markbranchmerged() {
  git branch -m $1 $1-merged
}

createlsbreleasebranchfromlsbmastertopchange() {
  topSHAId=$(git.getlatestcommitid)
  currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbrelease $(getnewbranchname $currentbranch $LSB_CURRENT_RELEASE)
  git cherry-pick $topSHAId
}

mergetomaster() {
  if git.hasUncommittedChanges 
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi


  if string.isemptyorblank $1
  then
    reviewrequestid=$(getcurrentreviewrequestid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetomaster $reviewrequestid      
    fi
  else
    currentbranch=$(git.getcurrentbranch)
    rebaselatestmaster
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to master"
    git checkout master
    echo "calling mergepush $currentbranch -r $1"
    mergepush $currentbranch -r $1
    git checkout $currentbranch
    # rename the current branch as 'merged' to keep for a few days
    markbranchmerged $currentbranch
  fi
}

mergetoreleasethenmaster() {
  if git.hasUncommittedChanges 
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi

  if string.isemptyorblank $1
  then
    reviewrequestid=$(getcurrentreviewrequestid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetoreleasethenmaster $reviewrequestid
    fi
  else
    reviewrequestid=$1
    # Merge to release first
    currentbranch=$(git.getcurrentbranch)
    rebaselatestrelease
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to release, otherwise press Ctrl+C and do it manually"
    git checkout $CURRENT_RELEASE
    mergepush $currentbranch -r $reviewrequestid

    # Merge changes back to master
    waitforenterkey "Merging changes to master now, press enter when ready"
    checkoutfromlatestmaster $currentbranch

    #Rename the current branch before reassigning
    markbranchmerged $currentbranch

    currentbranch=$(git.getcurrentbranch)    
    git merge $CURRENT_RELEASE

    # Validate that only your commits are included. If you see more than your changes here, wait for other authors to push  theirs, do pullmerge master after that or ask them if it is OK to push the changes to master.
    git log --format="%an: %s" master..$currentbranch

    waitforenterkey "Press enter if you see only your commits above, otherwise press Ctrl+C and do it manually"

    git checkout master
    mergepush $currentbranch -r $reviewrequestid --no-resolve # don't resolve the bug again, so fixed-in hash keeps pointing to the rel branch

    git checkout $currentbranch
    markbranchmerged $currentbranch
  fi
}


startservers() {
    startbelcad
    grunt quickServe
}

buildjavaonly() {
    export SKIP_CPP=1
    export SKIP_JSLIB=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JSLIB
}

buildjsonly() {
    export SKIP_CPP=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JAVA
}

buildcpponly() {
    export SKIP_JSLIB=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_JSLIB
    unset SKIP_JAVA
}

buildjavaandjsonly() {
    export SKIP_CPP=1
    buildgradleparallel
    unset SKIP_CPP
}

ptortest() {
 ptor $1 --verbose --flags=fastFail --target=http://localhost.dev.onshape.com:8000/
}

alias bsserverpath='/Users/pisoni/stage/BSServer/bin/BSServer'
alias buildall='cd $REPO_NEWTON;buildgradleparallel'
#alias buildjavaonly='grdlu gen java' #defined as a function in .profile
#alias buildjsonly='grdlu gen js' #defined as a function in .profile
alias checkJsCode='grunt checkJsCode'
alias checkjs='grunt eslint:javascript'
alias checkts='grunt eslint:typescript'
alias clion='open -a /Users/pisoni/Applications/JetBrains\ Toolbox/CLion.app'
alias cppbuild='buildcpponly'
alias droptoproduction='mongoDropToProduction'
alias eclipse='open -a /Applications/Eclipse.app'
alias eslintfix='grunt eslint:fix'
alias fixjs='grunt eslint:fix'
alias fixts='grunt eslint:fix'
alias fixpo='grunt xgettext --fix'
alias generateserializables='grunt generateSerializables'
alias genser='grunt generateSerializables'
alias gitlistskipignoredfiles='git ls-files -v . | grep ^S'
alias gruntQuickServe='grunt quickServe'
alias inteli='intellij'
alias intellij='idea' #Jetbrains Toolbox generates the script 'idea' for version dependent IntelliJ IDEA
alias javabuild='buildjavaonly'
alias jsbuild='buildjsonly'
alias jumpboxaddstaticroute='addstaticroutetojumpbox'
alias jumpboxnetstat='netstat -rn | grep 52.210.113.201'
alias jumpboxssh='sshjumpbox'
alias localprecommit='yarn precommit'
alias lsbreleasecheckout='checkoutfromlsbrelease'
alias lsbreleaserebaselatest='rebaselatestlsbrelease'
alias lsbreleasepulllatest='pulllatestlsbrelease'
alias lsbreleaserbtupdate='rbtupdatefromlsbrelease'
alias lsbreleaserbtpost='rbtpostfromlsbrelease'
alias mergelatestmaster='pullmerge master'
alias mongodump='mongoDump'
alias mongobackup='mongoDump'
alias mongorestore='mongoRestore'
alias backupmongo='mongoDump'
alias restoremongo='mongoRestore'
alias newton='cd $REPO_NEWTON'
alias pofix='fixpo'
alias prepeclipse='gradle prepEclipse'
alias prepclion='gradle :cpp:prepCLion --parallel'
alias protractortest='ptortest'
alias runprotractortest='ptortest'
alias runptortest='ptortest'
alias pulllatestmaster='pullmerge master'
alias pulllatestlsbmaster='pullmerge $LSB_MASTER'
alias pullmaster='pullmerge master'
alias pullmergemaster='pullmerge master'
alias pushtobuild='pushToBuildFarm @precommit @uitest @mocha'
alias pushtos3='pushToBuildFarm @promote-to-s3-test'
alias quickserve='grunt quickServe'
alias rebaselatestmaster='pullmerge master --rebase'
alias rebasemaster='pullmerge master --rebase'
alias serial='grunt generateSerializables'
alias serialize='grunt generateSerializables'
alias sshjumpbox='ssh -X pisoni@jumpbox-primary.dev.onshape.com'
alias startenv='startServices;startservers';
alias startServices='btEnvUp'
alias stopServices='btEnvDown'
alias startallservers='startservers'
alias restartServices='stopServices;startServices'
alias startfrontend='grunt quickServe'
alias updaterbt='rbt post -u -r'
alias xcode='open -a Xcode $STAGE/build/cppServer/DebugXcodeCCache/BTcppServer.xcodeproj/'
alias web='webstorm'
alias webs='webstorm'
alias storm='webstorm'
alias productionretrievalconfigfile='$STAGE/ModelingSvc/webapps/root/WEB-INF/config/applicationContext.xml'
