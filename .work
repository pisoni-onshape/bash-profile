export CURRENT_RELEASE=rel-1.143
export LSB_MASTER=lsb/master
export LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE

# This is only an issue if you usually extract std from stacks and upgrade has to process lot of std versions
# In that case, there might be out of memory problems while building java
export UPGRADE_MAX_MEMORY_GB=8

# Git related functions
function gitskipworktree() {
  git update-index --skip-worktree "$1"
}

function gitunskipworktree() {
  git update-index --no-skip-worktree $1
}

function backupbranch() {
  currentbranch=$(getcurrentbranch)
  searchstring=pisoni
  replacestring=backup/pisoni
  separator=/
  curdate=$(date +'%Y-%m-%d-%T')
  curdate="${curdate//:/-}"
  newbranch="${currentbranch/$searchstring/$replacestring}/$curdate"
  echo $newbranch
  # create new backup branch
  git checkout -b $newbranch
  # go back to our branch
  git checkout $currentbranch
}

function fixDiskImagesJS() {
  diskImageUmountAll
  rm ~/build_tools/diskimage/onshape-javascript_*
  source buildenv.bash  
}

runupgrade() {
  gradle runDocumentUpgrade -Donshape.upgrade.exitwhenfinished=true
}

runretrieval() {
  gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true
}

function makelikeproduction() {
  mongobackup
  stopbelcad
  mongoDropAll
  mongoDropToProduction
  export SKIP_INTERNAL_MODULES=1
}

function makelikeproductionwithbuild() {
  makelikeproduction
  buildgradleparallel
}

function openconfigpropertiesjson() {
  sublime $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
}

function setupforproductionretrieval() {
  echo "setting SKIP_INTERNAL_MODULES to 1"
  export SKIP_INTERNAL_MODULES=1
  sublime $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
  echo "Change the defaultValue of productionretrieval.write-s3 from false to true in the opened config-properties.json"
  waitforenterkey "Press enter when done"
  echo "Build (gradle) manually now using buildgradleparallel"
  #buildgradleparallel
  #waitforenterkey "Press enter when done"
  echo "call runupgrade to run document upgrade"
  #runupgrade
  #waitforenterkey "Press enter when upgrade has been done"
  echo "You can now see upgrade logs in $STAGE/ModelingSvc/logs/btserver.log"
  echo "Also, the upgrade data should be written to $STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  #open "$STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  echo "Finally, run the local production retrieval process by calling runretrieval"
  #runretrieval
}

function waitforenterkey() {
  read -p "$1"
}

runjunittest() {
    gradle safelyRunSpecificTests -Dtest=$1
}

awsconfigure() {
  btAws configure --profile codebuild
}

myprecommit() {
  checkTidy
  gradle :java:pmd
  grunt checkJsCode
}

addstaticroutetojumpbox() {
  sudo route -n add 54.187.217.158/32 $1
}

getnewbranchname() {
  inputbranchname=$1
  targetbranch=$2
  if ! (beginswith $inputbranchname "pisoni/")
  then
    inputbranchname=pisoni/$inputbranchname
  fi

  inputbranchname=$(simplereplace $inputbranchname "-lsb-*" "")
  inputbranchname=$(simplereplace $inputbranchname "-master" "")
  inputbranchname=$(simplereplace $inputbranchname "-release" "")
  targetbranch=$(simplereplace $targetbranch "/" "-")
  inputbranchname=$inputbranchname-$targetbranch

  echo $inputbranchname
}

function checkoutfrommaster() {
  git checkout master
  git pull
  git checkout -b $(getnewbranchname $1 "master")
}

function checkoutfromlsbbranch() {
  if isemptyorblank $1
  then
    echo "Please provide new branch name"
  elif isemptyorblank $2
  then
    echo "Please provide the base branch name"
  else
    gitBranchLsb $(getnewbranchname $1 "lsb/$2") $2
  fi
}

function checkoutfromlsbmaster() {
  checkoutfromlsbbranch "$1" "master" #lsb/ is eventually appended by gitBranchLsb
}

function checkoutfromlsbrelease() {
  checkoutfromlsbbranch "$1" "$CURRENT_RELEASE" #lsb/ is eventually appended by gitBranchLsb
}

rebaselatestlsbmaster() {
  pullmerge $LSB_MASTER --rebase
}

rebaselatestlsbrelease() {
  pullmerge $LSB_CURRENT_RELEASE --rebase
}

pulllatestlsbrelease() {
  pullmerge $LSB_CURRENT_RELEASE
}

rebaselatestrelease() {
  pullmerge $CURRENT_RELEASE --rebase
}

pulllatestrelease() {
  pullmerge $CURRENT_RELEASE
}

# Get the review request id associated with the current branch
# but only if it's in "Ship It!" state (to prevent accidentally 
# merging changes that are not yet approved)
function getcurrentreviewrequestid() {
  # convert multiline rbt status output to single line
  globalrbtstatus=$(rbt status | tr '\n' '\r')
  currentbranch=$(getcurrentbranch)
  shipitStr='Ship It\!'
  pendingStr='Pending'

  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  globalcurrentreviewrequestid=$(echo $globalrbtstatus | sed -En "s,.*$shipitStr[^|]+\| r\/([[:digit:]]+) [^|]+ \| $currentbranch \|.*,\1,p")
  echo $globalcurrentreviewrequestid
}

function getcurrentbranch() {
  globalcurrentbranch=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
  echo $globalcurrentbranch
}

# Unless otherwise specified, default branch for rbt is master
function rbtupdate() {
  if isemptyorblank $1
  then
    reviewrequestid=$(getcurrentreviewrequestid)
    if isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch"
      rbtupdate $reviewrequestid
    fi
  else
    echo "calling rbt post -u -r $1"
    rbt post -o -u -r $1
  fi
}

function rbtupdatewithrebase() {
  rebaselatestmaster
  rbtupdate
}

rbtpost() {
  rbt post -o
}

rbtpostwithrebase() {
  rebaselatestmaster
  rbtpost
}

rbtpostfromlsbmaster() {
  echo "Calling rbt post $LSB_MASTER...HEAD"
  rbt post -o $LSB_MASTER...HEAD
}

rbtpostfromlsbrelease() {
  echo "Calling rbt post $LSB_CURRENT_RELEASE...HEAD"
  rbt post -o $LSB_CURRENT_RELEASE...HEAD
}


rbtupdatefrombranch() {
  if isemptyorblank $1
  then
    echo "Please give the branch name"
  elif isemptyorblank $2
  then
    reviewrequestid=$(getcurrentreviewrequestid)
    if isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch"
      rbtupdatefrombranch $1 $reviewrequestid
    fi
  else
    echo "Calling rbt post -u -r $2 $1...HEAD"
    rbt post -o -u -r $2 $1...HEAD
  fi
}

rbtupdatefromlsbrelease() {
  rbtupdatefrombranch $LSB_CURRENT_RELEASE $1
}

rbtupdatefromlsbmaster() {
  rbtupdatefrombranch $LSB_MASTER $1
}

rbtupdatefromlsbreleasewithrebase() {
  rebaselatestlsbrelease
  rbtupdatefromlsbrelease
}

rbtupdatefromlsbmasterwithrebase() {
  rebaselatestlsbmaster
  rbtupdatefromlsbmaster
}

setupjumpboxcertificates() {
  export USERNAME=pisoni
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USERNAME.key /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USERNAME.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:ca.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:tls-auth.key /tmp  
}

restartbelcad() {
  stopbelcad
  startbelcad
}

beep() {
  tput bel
}

playfinishsound() {
  beep;beep;
  say "Build Complete"
}

buildgradleparallel() {
  gradle --parallel
  playfinishsound
}

mergetomaster() {
  if isemptyorblank $1
  then
    reviewrequestid=$(getcurrentreviewrequestid)
    if isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetomaster $reviewrequestid      
    fi
  else
    currentbranch=$(getcurrentbranch)
    rebaselatestmaster
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to master"
    git checkout master
    echo "calling mergepush $currentbranch -r $1"
    mergepush $currentbranch -r $1
  fi
}

#Not complete yet
#mergetoreleasethenmaster() {
#  if isemptyorblank $1
#  then
#    echo "Please give the review request id"
#  else
#    currentbranch=$(getcurrentbranch)
#    rebaselatestrelease
#    waitforenterkey "Press enter if and when rebase is successful"
#    git checkout $CURRENT_RELEASE
#    mergepush $currentbranch -r $1
#
#    #Push changes to master
#    waitforenterkey "Pushing changes to master now, press enter when ready"
#    git checkout master
#    git pull
#    git checkout -b
#  fi
#}

testfunc() {
  if [[ "$1" == "piyush" ]]
  then
    echo 'yes'
  else
    echo 'no'
  fi
}



startservers() {
    startbelcad
    grunt quickServe
}

buildjavaonly() {
    export SKIP_CPP=1
    export SKIP_JSLIB=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JSLIB
}

buildjsonly() {
    export SKIP_CPP=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JAVA
}

buildcpponly() {
    export SKIP_JSLIB=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_JSLIB
    unset SKIP_JAVA
}

buildjavaandjsonly() {
    export SKIP_CPP=1
    buildgradleparallel
    unset SKIP_CPP
}

ptortest() {
 ptor $1 --verbose --flags=fastFail --target=http://localhost.dev.onshape.com:8000/
}

alias bsserverpath='/Users/pisoni/stage/BSServer/bin/BSServer'
alias buildall='cd $REPO_NEWTON;buildgradleparallel'
#alias buildjavaonly='grdlu gen java' #defined as a function in .profile
#alias buildjsonly='grdlu gen js' #defined as a function in .profile
alias checkJsCode='grunt checkJsCode'
alias checkjs='grunt eslint:javascript'
alias checkts='grunt eslint:typescript'
alias clion='open -a /Users/pisoni/Applications/JetBrains\ Toolbox/CLion.app'
alias cppbuild='buildcpponly'
alias droptoproduction='mongoDropToProduction'
alias eclipse='open -a /Applications/Eclipse.app'
alias eslintfix='grunt eslint:fix'
alias fixjs='grunt eslint:fix'
alias fixts='grunt eslint:fix'
alias fixpo='grunt xgettext --fix'
alias generateserializables='grunt generateSerializables'
alias genser='grunt generateSerializables'
alias gitlistskipignoredfiles='git ls-files -v . | grep ^S'
alias gruntQuickServe='grunt quickServe'
alias inteli='intellij'
alias intellij='idea' #Jetbrains Toolbox generates the script 'idea' for version dependent IntelliJ IDEA
alias javabuild='buildjavaonly'
alias jsbuild='buildjsonly'
alias jumpboxaddstaticroute='addstaticroutetojumpbox'
alias jumpboxnetstat='netstat -rn | grep 52.210.113.201'
alias jumpboxssh='sshjumpbox'
alias localprecommit='yarn precommit'
alias lsbreleasecheckout='checkoutfromlsbrelease'
alias lsbreleaserebaselatest='rebaselatestlsbrelease'
alias lsbreleasepulllatest='pulllatestlsbrelease'
alias lsbreleaserbtupdate='rbtupdatefromlsbrelease'
alias lsbreleaserbtpost='rbtpostfromlsbrelease'
alias mergelatestmaster='pullmerge master'
alias mongodump='mongoDump'
alias mongobackup='mongoDump'
alias mongorestore='mongoRestore'
alias backupmongo='mongoDump'
alias restoremongo='mongoRestore'
alias newton='cd $REPO_NEWTON'
alias pofix='fixpo'
alias prepeclipse='gradle prepEclipse'
alias prepclion='gradle :cpp:prepCLion --parallel'
alias protractortest='ptortest'
alias runprotractortest='ptortest'
alias runptortest='ptortest'
alias pulllatestmaster='pullmerge master'
alias pulllatestlsbmaster='pullmerge $LSB_MASTER'
alias pullmaster='pullmerge master'
alias pullmergemaster='pullmerge master'
alias pushtobuild='pushToBuildFarm @precommit @uitest @mocha'
alias pushtos3='pushToBuildFarm @promote-to-s3-test'
alias quickserve='grunt quickServe'
alias rebaselatestmaster='pullmerge master --rebase'
alias rebasemaster='pullmerge master --rebase'
alias serial='grunt generateSerializables'
alias serialize='grunt generateSerializables'
alias sshjumpbox='ssh -X pisoni@jumpbox-primary.dev.onshape.com'
alias startenv='startServices;startservers';
alias startServices='btEnvUp'
alias stopServices='btEnvDown'
alias startallservers='startservers'
alias restartServices='stopServices;startServices'
alias startfrontend='grunt quickServe'
alias updaterbt='rbt post -u -r'
alias xcode='open -a Xcode $STAGE/build/cppServer/DebugXcodeCCache/BTcppServer.xcodeproj/'
alias web='webstorm'
alias webs='webstorm'
alias storm='webstorm'
alias productionretrievalconfigfile='$STAGE/ModelingSvc/webapps/root/WEB-INF/config/applicationContext.xml'
