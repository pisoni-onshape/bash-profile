#git utilities

#include guard
[ ! -z "$git_defined" ] && [ -z "$FORCE_IMPORT_UTILITY" ] && return 0


export git_defined=1
export GIT_SKIP_TREE_FILES_LIST=~/.git-skipped-worktree-files


# Import utility modules
importutility string
importutility system

function git.renamebranch() {
	git branch -m $1 $2
}

function git.renamecurrentbranch() {
	git branch -m $1
}

function git.getcurrentbranch() {
  local currentbranch=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
  echo $currentbranch
}

function git.hasUncommittedChanges() {
	[ -n "$(git status --porcelain)" ]
}

function git.getlatestcommitid() {
	local latestSHAId=$(git rev-parse HEAD | cut -c 1-8)
	echo $latestSHAId
}

function git.branchislsbreleasebased() {
	local currentbranch=$(git.getcurrentbranch)
	string.endswith $currentbranch "-lsb-rel-[0-9].[0-9]*"
}

function git.branchislsbmasterbased() {
	local currentbranch=$(git.getcurrentbranch)
	#echo $currentbranch
	string.endswith $currentbranch "-lsb-master"
}


function git.branchisreleasebased() {
	local currentbranch=$(git.getcurrentbranch)
	! git.branchislsbreleasebased && string.endswith $currentbranch "-rel-[0-9].[0-9]*"
}

function git.branchismasterbased() {
	local currentbranch=$(git.getcurrentbranch)
	! git.branchislsbmasterbased && string.endswith $currentbranch "-master"
}

# Give the full file path for the _tracked_ file you want to ignore
function git.skipworktree() {
  git update-index --skip-worktree "$1"
  system.createfileifdoesnotexist $GIT_SKIP_TREE_FILES_LIST
  echo "$1">>$GIT_SKIP_TREE_FILES_LIST
}

function git.unskipworktree() {
  git update-index --no-skip-worktree $1
  if system.ismacos
  then
    # Seems this empty backup is required.
    sed -i '' "s|$1||g" $GIT_SKIP_TREE_FILES_LIST
  else
    sed -i "s|$1||g" $GIT_SKIP_TREE_FILES_LIST
  fi
}

function git.openskipworktreefile() {
  edit $GIT_SKIP_TREE_FILES_LIST
}

# ToDo : Refactor the common code out of the below two functions
function git.backupbranch() {
  local currentbranch=$(git.getcurrentbranch)
  local searchstring=$USER
  local replacestring=backup/$USER
  local curdate=$(system.getcurrentdate)
  local additionalNotes=""
  if string.isnotemptyorblank $1
  then
    # Replace spaces with hyphens
    additionalNotes=$(string.simplereplace "/$1" " " "-")
  fi

  local newbranch="${currentbranch/$searchstring/$replacestring}$additionalNotes/$curdate"
  echo $newbranch
  # create new backup branch
  git checkout -b $newbranch
  # go back to our branch
  git checkout $currentbranch
}

# Backup the current branch but mark that as 'starred', more important
# than the usual backups
function git.starbackupbranch() {
  currentbranch=$(git.getcurrentbranch)
  searchstring=$USER
  replacestring=starred/$USER
  separator=/
  curdate=$(system.getcurrentdate)
  newbranch="${currentbranch/$searchstring/$replacestring}/$curdate"
  echo $newbranch
  # create new backup branch
  git checkout -b $newbranch
  # go back to our branch
  git checkout $currentbranch
}

function git.getbugnumberfromcurrentbranch() {
  local currentbranch=$(git.getcurrentbranch)
  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  local bugnumber=$(echo $currentbranch | sed -En "s,.*/bel-([[:digit:]]+)/.*,BEL-\1,p")
  echo $bugnumber
}

function git.commit() {
  local bugnumber=$(git.getbugnumberfromcurrentbranch)
  git status
  local message=""
  if string.isnotemptyorblank $1
  then
    message="$bugnumber"": $1"
  else
    message="$bugnumber"": more changes"
  fi

  echo "Adding files in the current directory to staging"
  git add .
  git commit -m "$message"
}

# Return true if a remote branch with a given substring of the branchname exists
function git.remotebranchexists() {
  string.isnotemptyorblank $(git ls-remote --heads origin "$1")
}

function git.localbranchexists() {
  system.commandsucceeds $(git show-ref --quiet refs/heads/$1)
}

# List all branches that are not "backup", "merged" or "archived"
function git.listbranches() {
  git branch | grep -v -e "backup/" -e "merged/" -e "archived/"
}

# Creates a patch for the latest commit in your branch
function git.patchlatestcommit() {
  git.patchcommit "HEAD"
}

# Creates a patch for the specified commit in your branch
function git.patchcommit() {
  git format-patch -1 $1 # Commit SHA1 id
}

alias stoptrackingfile='git.skipworktree'
alias starttrackingfile='git.unskipworktree'
