#!/bin/bash
shopt -s expand_aliases

# Official exports:
# -----------------
# CPP compiler cache
export USE_CCACHE=1

# Debug cpp build
export RELEASE=0

# Measure load times in viewer (can view in timer.log)
export BTI_ENABLE_TIMERS=1

# So that BSServer doesn't time out so early
export BTI_DISABLE_HEARTBEATS=1

# # So that thumbnails are generated in the dev environment (off by default)
# # Remove if not needed.
# export ENABLE_THUMBNAIL_SERVICE=1

# # For creating drawings shaded view (BEL-216201)
# export START_RENDERER_IN_MAIN_THREAD=1


# If debugging BSServer, cut down on the number of BSServers available to attach to
# ****** CAUTION: REMOVE WHEN WORKING WITH THUMBNAILS, otherwise it won't create Thumbnail
# cpp server pool ******
export BTI_BLOCK_THUMBNAIL_CPP_SERVER_POOL=1

# Remove unnecessary deprecation warning
export BASH_SILENCE_DEPRECATION_WARNING=1

# Improve artifactory download performance from S3, but sometimes causes other problems. Use only when
# facing problem with the default region (which is typically us-west-2)
#export OBJECT_STORE_REPO_REGION=ap-south-1

#export HOST_PROPERTIES_PRIVATEIP="$(dockerCreateLoopbackAlias)"
# This is only an issue if you usually extract std from stacks and upgrade has to process lot of std versions
# In that case, there might be out of memory problems while building java
export UPGRADE_MAX_MEMORY_GB=8
export JAVA_MAX_MEMORY_MB=8192
# Use jaeger for local tracing instead of SignalFx:
export DEV_SIGNALFX_TRACING=2
# Dev Tools Path
export DEV_TOOLS=$HOME/repos/onshape-dev-tools

# Others
#set -o nounset # Make the script fail if trying to access an unset variable.

# Check if the current directory is either
# 'newton' or newton<n> where n is a number
function dirismultienvnewton() {
	local regexNewtonLike='^newton$|^newton[1-9][0-9]*$'
	[[ $1 =~ $regexNewtonLike ]]
}

# Ensure we're in the newton directory
# or one of its subdirectories.
function ensurenewtondirectory() {
  if string.isemptyorblank $REPO_NEWTON
  then
    # Should be the case when we've just started the Terminal.
    local currentdirname=$(system.dirnamefrompath $(pwd))
    if ! dirismultienvnewton $currentdirname
    then
      # $REPO_NEWTON is not set, and we are
      # also not in a newton/newton<n> like directory
      # assume newton '1'.
      cd $HOME/repos/newton
    fi

    # now when a newton like directory is ensured,
    # call the buildenv.bash script
    source buildenv.bash
    exportAfterInitVariables
    platformspecificsettings
  elif ! string.contains $(pwd) $REPO_NEWTON
  then
    # $REPO_NEWTON is initialized but we're not in it or one of its subdirectories
    cd $REPO_NEWTON
  fi
}

# Unofficial exports
# ------------------
# Now when the environment should be set, some exports used by this script:
function exportAfterInitVariables() {
  local envNum=$(getEnvNumber)
  export CURRENT_RELEASE=$(system.readvarfromdisk CURRENT_RELEASE $envNum)
  export LSB_MASTER=lsb/master
  export LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE
  export GIT_MERGE_AUTOEDIT=no
  export RETRIEVAL_REPORT_WRITE_TO_DISK=1
  export PATH="$HOME/Library/Python/3.8/bin:${PATH}" # Mostly so that 'rbt' works.
  export btserverwebpath="$STAGE/WebSvc/logs/btserver.log"
  export btservermodpath="$STAGE/ModelingSvc/logs/btserver.log"
  export timerlogwebpath="$STAGE/WebSvc/logs/timer.log"
  export timerlogmodpath="$STAGE/ModelingSvc/logs/timer.log"
  export upgradelogwebpath="$STAGE/WebSvc/logs/upgrade.log"
  # Sometimes, for some reason the logs go in the logsDir_IS_UNDEFINED directory
  # No one seems to know the exact reason at the time of writing this.
  export undefinedbtserverwebpath="$STAGE/WebSvc/logsDir_IS_UNDEFINED/btserver.log"
  export undefinedbtservermodpath="$STAGE/ModelingSvc/logsDir_IS_UNDEFINED/btserver.log"
  export undefinedtimerlogwebpath="$STAGE/WebSvc/logsDir_IS_UNDEFINED/timer.log"
  export DEFAULT_GRUNT_SERVE_PORT="8000"

  # Set GRUNT_SERVE_PORT according to the env number
  export GRUNT_SERVE_PORT=$(($DEFAULT_GRUNT_SERVE_PORT+$envNum))
}

# Import Utility modules
importutility string
importutility system
importutility git
importutility rbt
importutility general


# Set CPP builder according to the platform
function platformspecificsettings() {
  if system.ismacos
  then
    echo "Detected macOS, using XCODEBUILD"
    unset CLIONBUILD
    export XCODEBUILD=1
  else # Assume Linux for now.
    echo "Using CLIONBUILD for building C++"
    unset XCODEBUILD
    export CLIONBUILD=1
  fi
}

function setrelease() {
  if string.equals $1 "0"
  then
    export RELEASE=0
    echo "Set to build in debug mode"
  else #empty or any other argument.
    export RELEASE=1
    echo "Set to build in release mode"
  fi
}

function setdebug() {
  if string.equals $1 "0"
  then
    export RELEASE=1
    echo "Set to build in release mode"
  else #empty or any other argument.
    export RELEASE=0
    echo "Set to build in debug mode"
  fi
}

# INCOMPLETE function. Find next onshape version given the input version
# Or a few versions forward or backward if a second +/- integer is sent
# to add to it
function newonshapeversion() {
  local original=$1
  local addition=1
  if ! string.isemptyorblank $2
  then
    addition=$2
  fi

  # Trim everything before "."
  local prefix=$(string.simplereplace "$original" ".*" "")
  # Trim everything before "."
  local version=$(string.simplereplace "$original" "*." "")
  local newsuffix=$(general.add $version $addition)
  echo "$prefix.$newsuffix"
}

function refreshcurrentreleasebranch() {
  CURRENT_RELEASE=""

  # The current release can only either be the current
  # newton version, or one before it.
  local extension=$(getEnvNumber)

  CURRENT_RELEASE=$(system.readvarfromdisk CURRENT_RELEASE $extension)
  # So if it's already equivalent to NEWTON_VERSION,
  # there's no point pulling latest branch from github
  # (as we wrote in the file in the first place)
  if ! string.equals "$CURRENT_RELEASE" "rel-$NEWTON_VERSION"
  then
    echo "Refreshing CURRENT_RELEASE (pulling from remote) ..."
    CURRENT_RELEASE="rel-$NEWTON_VERSION"
    if ! git.remotebranchexists $CURRENT_RELEASE
    then
      CURRENT_RELEASE=$(newonshapeversion $CURRENT_RELEASE -1)
    fi
  fi

  # Refresh the current lsb release branch as well.
  LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE
  echo "CURRENT_RELEASE set to $CURRENT_RELEASE"

  # Write current release to a file
  system.writevartodisk CURRENT_RELEASE $extension
}

function debugstaging() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://staging.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugdemoc() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://demo-c.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugproduction() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://cad.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function removeDiskImages() {
  rm -rf $HOME/build_tools/diskimage
}

function fixDiskImagesJS() {
  diskImageUmountAll
  rm $BUILD_TOOLS/diskimage/onshape-javascript_*
  source buildenv.bash
}

function importextractedfile() {
  local time1=$SECONDS
  waitforenterkey "If the file doesn't include std, make sure you've run 'mongoDropToProduction' and 'gradle runBtUpgrade' before this (press enter if yes, and Ctrl+C if you haven't)"
  # restoreDump "$1" --nodrop --remap=btadmin@onshape.com
  restoreDump "$1" --nodrop --remap=pisoni@onshape.com
  local time2=$SECONDS
  local duration=$(($time2-$time1))
  echo "Time taken in restore: $duration seconds"
  say "Document import complete"
}

function runupgrade() {
  gradle runDocumentUpgrade -Donshape.upgrade.exitwhenfinished=true
}

function runretrieval() {
  waitforenterkey "Have you run setupforproductionretrieval before this? If yes, press Enter, else press Ctrl+C and do that first."

  if string.isemptyorblank $1
  then
    echo "A numeric Jenkins build id is required"
    return
  fi

  # If there's a second argument specified, take it as the documentidregex string
  # input to the retrieval service (which you should ideally pass without spaces,
  # as I haven't tested what will happen with spaces in these arguments :) )
  if string.isemptyorblank $2
  then
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1
  else
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1 -Donshape.productionretrieval.documentidregex=$2
  fi
}

function makelikeproduction() {
  #Make sure Docker is running, and mongo service is running as well
  mongoDumpDb #Note where it's created
  stopbelcad
  mongoDropAll
  mongoDropToProduction
  export SKIP_INTERNAL_MODULES=1
  waitforenterkey "Press enter if gradle runBtUpgrade is needed, else press Ctrl.+C to end"
  gradle runBtUpgrade
}

function cleandocker() {
  dockerKillAll
  #docker rmi $(docker images -qf "dangling=true"    #Cleans dangligng images
  #docker-compose rm -f   #Clean old images
  docker system prune -f
  docker volume prune -f
}

function cleanjars() {
  find "$HOME/stage/build/" -name *.jar -delete
}

function makelikeproductionwithbuild() {
  makelikeproduction
  buildgradleparallel # Then restore dump, and then it might need gradle runBtUpgrade again before running runupgrade
}

function openconfigpropertiesjson() {
  texteditor $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
}

function openupgradelogweb() {
  edit $upgradelogwebpath
}

function openbttimerlogweb() {
  edit $timerlogwebpath
}

function openbtserverweblog() {
  texteditor $btserverwebpath
}

function openbtservermodlog() {
  texteditor $btservermodpath
}

function opentimerlogweb() {
  texteditor $timerlogwebpath
}

function opentimerlogmod() {
  texteditor $timerlogmodpath
}

function cleanbtserverweblog() {
  system.cleanfilecontents "$btserverwebpath" "--silent"
}

function cleanbtservermodlog() {
 system.cleanfilecontents "$btservermodpath" "--silent"
}

function cleanlogs() {
  # These should not be needed and aren't even used in normal cases,
  # but sometimes our logs go into the logsDir_IS_UNDEFINED directory
  # for some reasons.
  system.cleanfilecontents "$undefinedtimerlogwebpath" "--silent"
  system.cleanfilecontents "$undefinedbtserverwebpath"
  system.cleanfilecontents "$undefinedbtservermodpath"

  cleanbtserverweblog
  cleanbtservermodlog
  system.cleanfilecontents "$timerlogwebpath" "--silent"
  system.cleanfilecontents "$timerlogmodpath" "--silent"
  system.cleanfilecontents "$upgradelogwebpath" "--silent"
}

function setupforproductionretrieval() {
  # First make your environment 'like' production (though that might not be necessary to just 'run' and debug the code)
  #makelikeproduction
  echo "setting SKIP_INTERNAL_MODULES to 1"
  export SKIP_INTERNAL_MODULES=1
  openconfigpropertiesjson
  echo "Change the defaultValue of productionretrieval.write-s3 from false to true in the opened config-properties.json"
  waitforenterkey "Press enter when done"
  echo "Build (gradle) manually now using buildgradleparallel"
  #buildgradleparallel
  #waitforenterkey "Press enter when done"
  echo "Import documents to upgrade."
  echo "call runupgrade to run document upgrade"
  #runupgrade
  #waitforenterkey "Press enter when upgrade has been done"
  echo "You can now see upgrade logs in $STAGE/ModelingSvc/logs/btserver.log"
  echo "Also, the upgrade data should be written to $STAGE/MockS3/onshape-myregion/test/operations/myenv/regen-data"
  #open "$STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  echo "Finally, run the local production retrieval process by calling runretrieval"
  #runretrieval
}

function waitforenterkey() {
  read -p "$1"
}

function openmocks3cache() {
  local envNum=$(getEnvNumber)
  local envString="myenv"
  if ! string.equals $envNum "0"
  then
    envString="myenv$envNum"
  fi

  open "$STAGE/MockS3/onshape-cache-us-west-2/test/cache/$envString/c/15"
}

function runjunittest() {
    gradle safelyRunSpecificTests -Dtest=$1
}

function awsconfigure() {
  btAws configure --profile codebuild
}

function checkpmd() {
  gradle :java:pmd
}

function myprecommit() {
  # Remove this first line once yarn precommit starts catching
  # typescript errors again
  #npx tsc --noEmit --project $REPO_NEWTON/project/web/tsconfig.json
  checkTidy && checkpmd && (grunt checkJsCode)
}

function addstaticroutetojumpbox() {
  sudo route -n add 54.187.217.158/32 $1
}

function getnewbranchname() {
  local inputbranchname=$(string.tolower $1)
  local targetbranch=$(string.tolower $2)

  # Remove all lsb-release, lsb-master, -master, rel- etc. suffixes from the branch  name
  inputbranchname=$(string.simplereplace $inputbranchname "-lsb-*" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-master" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-release" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-rel-[1-9]*" "")
  # Since we're creating a new branch, remove the 'merged'/'archived' words if there
  inputbranchname=$(string.simplereplace $inputbranchname "merged/" "")
  inputbranchname=$(string.simplereplace $inputbranchname "archived/" "")

  if ! (string.beginswith $inputbranchname "$USER/")
  then
    inputbranchname=$USER/$inputbranchname
  fi

  if string.isnotemptyorblank $targetbranch
  then
    targetbranch=$(string.simplereplace $targetbranch "/" "-")
    inputbranchname=$inputbranchname-$targetbranch
  fi

  echo $inputbranchname
}

function checkoutfrommaster() {
  ensurenewtondirectory
  git checkout master
  git pull
  git checkout -b $(getnewbranchname $1 "master")
  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromrelease() {
  ensurenewtondirectory
  git checkout $CURRENT_RELEASE
  git pull
  git checkout -b $(getnewbranchname $1 $CURRENT_RELEASE)
  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromlsbbranch() {
  if string.isemptyorblank $1
  then
    echo "Please provide new branch name"
  elif string.isemptyorblank $2
  then
    echo "Please provide the base branch name"
  else
    gitBranchLsb $(getnewbranchname $1 "lsb/$2") $2
  fi

  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromlsbmaster() {
  ensurenewtondirectory
  checkoutfromlsbbranch "$1" "master" #lsb/ is eventually appended by gitBranchLsb
}

function checkoutfromlsbrelease() {
  ensurenewtondirectory
  checkoutfromlsbbranch "$1" "$CURRENT_RELEASE" #lsb/ is eventually appended by gitBranchLsb
}

function rebaselatest() {
  pulllatest "rebase"
}

# Unless otherwise specified, default branch for rbt is master
function pulllatest() {
  local branchname=$(git.getcurrentbranch)
  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Rebasing w.r.t. to that"
    pulllatestbranch "$LSB_MASTER" $1 # Assuming $1 would be "rebase" when needed (e.g. called from rebaselatest), and empty otherwise
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Rebasing w.r.t. to that"
    if string.isemptyorblank "$LSB_CURRENT_RELEASE"
    then
        refreshcurrentreleasebranch
    fi

    if string.isnotemptyorblank "$LSB_CURRENT_RELEASE"
    then
        pulllatestbranch "$LSB_CURRENT_RELEASE" $1
    else
        echo "refreshing CURRENT_RELEASE and LSB_CURRENT_RELEASE failed. Please set them manually. Exiting now."
        return 1
    fi
  elif git.branchismasterbased || string.equals "$branchname" "master"
  then
    echo "Detected master based branch. Rebasing w.r.t. to that"
    pulllatestbranch "master" $1
  elif git.branchisreleasebased || string.equals "$branchname" "$CURRENT_RELEASE"
  then
    echo "Detected rel-* based branch. Rebasing w.r.t. to that"
    if string.isemptyorblank "$CURRENT_RELEASE"
    then
        refreshcurrentreleasebranch
    fi

    if string.isnotemptyorblank "$CURRENT_RELEASE"
    then
        pulllatestbranch "$CURRENT_RELEASE" $1
    else
        echo "refreshing CURRENT_RELEASE failed. Please set it manually. Exiting now."
        return 1
    fi
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based rebase"
    pulllatestbranch "master" $1
  fi
}

function rebaselatestbranch() {
  pulllatestbranch $1 "rebase"
}

function pulllatestbranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  else
    local argument=""
    if string.contains "$2" "rebase" || string.equals "$2" "-r"
    then
      argument="--rebase"
    fi

    echo "Calling pullmerge $1 $argument"
    pullmerge "$1" $argument
    if system.waslastcommandsuccessful
    then
      echo "$USER: pullmerge successful"
      return 0
    else
      echo "$USER: pullmerge failed"
      return 1 # failure
    fi
  fi
}

# rbt post and updates
function rbtpostfrombranch() {
  local sourcebranch="$1"
  if string.isemptyorblank $sourcebranch
  then
    echo "Please give the branch name w.r.t. which you want to create diff"
    return 1
  fi

  # Populate information for the 'Bugs' field on rbcommons page
  local bugNumberStr=""
  local bugNumber=$(git.getbugnumberfrombranch)
  if ! string.isemptyorblank $bugNumber
  then
    bugNumberStr="--bugs-closed $bugNumber"
  fi

  # Populate information for the 'Branch' field on rbcommons
  local branchStr="--branch master"
  if string.contains $sourcebranch "rel-"
  then
    branchStr="--branch $CURRENT_RELEASE"
  fi

  # To-Do : Handle --target-people <username,...> (reviewers)
  local extension=$(getEnvNumber)
  local reviewers=$(system.readvarfromdisk RBT_REVIEWERS $extension)
  if ! string.isemptyorblank $reviewers
  then
    reviewers="--target-people ""$reviewers"
  fi

  echo "Calling rbt post -o $branchStr $bugNumberStr $reviewers $sourcebranch...HEAD"
  rbt post -o $branchStr $bugNumberStr $reviewers $sourcebranch...HEAD
}

# If a single or comma separated reviewer id is set (what you put in rbcommons reviewers list)
# it will be auto populated in the created review requests.
function setrbtreviewer() {
  local RBT_REVIEWERS="$1"

  system.writevartodisk RBT_REVIEWERS $(getEnvNumber)
}

# Return the branch name/tag this branch is based off
# e.g. master, lsb/master etc. For this, the branch must have
# been created using checkoutfrommaster / checkoutfromlsbmaster etc. commands
function getbasebranchname() {
  # Check if there was a remote prefix
  # passed. Only use for branch names, not tag names.
  local remoteprefix=""
  if string.isnotemptyorblank $1
  then
    remoteprefix="$1/"
  fi

  if git.branchislsbmasterbased
  then
    echo $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "$remoteprefix""master"
  elif git.branchisreleasebased
  then
    echo "$remoteprefix""$CURRENT_RELEASE"
  else
    echo "" # Can't find out.
  fi
}

# Unless otherwise specified, default branch for rbt is master
function rbtpost() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before proceeding."
    return
  fi

  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch "master"
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $CURRENT_RELEASE
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based diff"
    rbtpostfrombranch "master"
  fi
}

function rbtupdatefrombranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  elif string.isemptyorblank $2
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_ANY)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find a matching review request for the branch, enter manually."
    else
      echo "Automatically found review request id: $reviewrequestid for current branch"
      rbtupdatefrombranch $1 $reviewrequestid
    fi
  else
    echo "Calling rbt post -o -u -r $2 $1...HEAD"
    rbt post -o -u -r $2 $1...HEAD
  fi
}

# Unless otherwise specified, default branch for rbt is master
function rbtupdate() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before proceeding."
    return
  fi

  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch "master"
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $CURRENT_RELEASE
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based diff"
    rbtupdatefrombranch "master"
  fi
}

function rbtpostwithrebase() {
  rebaselatest
  if system.waslastcommandsuccessful
  then
    rbtpost
  else
    echo "Not calling rbtpost as rebase was not successful."
  fi
}

function rbtupdatewithrebase() {
  rebaselatest
  if system.waslastcommandsuccessful
  then
    rbtupdate
  else
    echo "Not calling rbtupdate as rebase was not successful."
  fi
}

function testregex() {
  var1='rel-1'
  var2='rel-[0-9]*'
  if [[ 'rel-1' =~ 'rel-[0-9]*' ]]
  then
    echo yes
  else
    echo no
  fi

  check_dec='^rel-[0-9]\.[0-9]+'
  input=0

  echo "Please enter a digit: "
  read input

  if [[ $input =~ $check_dec ]]
  then
           echo "The value is a decimal"
  else
          echo "The value is something else"
  fi
}

function setupjumpboxcertificates() {
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.key /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:ca.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:tls-auth.key /tmp
}

# Multi-env aware
function getbelcadpid() {
  local jettypid=$(ps -ef | grep jetty | grep "$STAGE/" | awk '{print $2}')
  echo $jettypid
}

# Multi-env aware
# Prints an output (True/False) only when called
# directly from the Terminal (else returns true/false)
function isonshapeserverrunning() {
  local jettypid=$(getbelcadpid)
  if calledfromterminal
  then
    if string.isemptyorblank $jettypid
    then
      echo "No."
    else
      echo "Yes, PID : $jettypid"
    fi
  fi

  string.isnotemptyorblank $jettypid
}

# Assumes pid to kill is a valid one
function killprocessid() {
  echo "Killing $2 PID $1"
  kill -9 $1

  if ! string.equals $3 "nosleep"
  then
    # Allow the process to be killed (I observed a couple of times that it doesn't immediately get killed
    # and the next command like system.whoisusingport 8080 still shows that PID)
    sleep 2
  fi
}

function stopallservices() {
  . "${TOOLS_BASH}/lib/docker/stopDockerContainer.bash"
  btEnvDown
  stopZookeeperIfRunning
  stopDockerContainer dns-proxy
  stopDockerContainer $(getContainerName https)
  if isdebuggingdrawings
  then
    stopDrawingDocker
  fi
}

# Test if a function is called directly
# from terminal or from another function.
function calledfromterminal() {
  #caller | awk '{print $2}'
  # ${FUNCNAME[2]} represents the caller name of *this* function.
  # Empty if caller was called directly from terminal.
  (string.isemptyorblank "${FUNCNAME[2]}")
}

# Multi-env aware as long as GRUNT_SERVE_PORT is defined
function getquickservepid() {
  local port=$GRUNT_SERVE_PORT
  if string.isemptyorblank $port
  then
    port=8000
  fi
  local searchString="node.*127\.0\.0\.1:$port.*LISTEN"

  local pid=$(lsof -iTCP -n -P | grep "$searchString" | awk '{print $2}')
  echo $pid
}

# Multi-env aware as long as GRUNT_SERVE_PORT is defined
function isquickserverunning() {
  local pid=$(getquickservepid)

  if calledfromterminal
  then
    if string.isemptyorblank $pid
    then
      echo "No."
    else
      echo "Yes, PID : $pid"
    fi
  fi

  string.isnotemptyorblank $pid
}

function areserversrunning() {
  local hasError="false"

  if ! isonshapeserverrunning
  then
    hasError="true"
    echo "Onshape server is NOT running"
  else
    echo "Onshape server is running"
  fi

  if ! isquickserverunning
  then
    hasError="true"
    echo "quickServe is NOT running"
  else
    echo "quickServe is running"
  fi

  if string.equals $hasError "false"
  then
    # echo "Both Onshape server and grunt quickServe are running."
    return 0 # success
  else
    return 1
  fi
}

function fstopquickserve() {
  local pid=$(getquickservepid)
  if ! string.isemptyorblank $pid
  then
    killprocessid $pid "quickserve" $1 # this optional argument can be "nosleep"
  else
    echo "Didn't find quickserve process to kill"
  fi
}

function fstopbelcad() {
  # Consider using this instead, which is multi-env aware: checkServices -s websvc
  local jettypid=$(getbelcadpid)
  if ! string.isemptyorblank $jettypid
  then
    killprocessid $jettypid "jetty" $1 # this optional argument can be "nosleep"
  else
    echo "Didn't find onshape process to kill"
  fi
}

# Another version of the official 'checkServices'. Tells you if
function checkessentialservices() {
  local output=$(checkServices)

  declareEssentialServices

  local allRunning="true"
  for entry in "${ESSENTIAL_SERVICES_AND_COMMANDS[@]}" ; do
      service=${entry%%:*}
      local serviceRunning=$(echo $output | grep "$service.. ok docker container")

      if string.isemptyorblank $serviceRunning
      then
        echo "Essential service $service is not running"
        allRunning="false"
      fi
  done

  if string.equals $allRunning "true"
  then
    echo "All essential services are running"
    return 0
  else
    return 1
  fi
}

function fastcheckessentialservices() {
  local envString=""
  local envNumber=$(getEnvNumber)
  local autoFix=$1
  local autoFixString=""
  if string.equals $autoFix "true"
  then
    autoFixString=", starting it"
  fi

  if ! string.equals $envNumber "0"
  then
    envString="_myenv$envNumber"
  fi

  declareEssentialServices

  local runningServicesArray=( $(docker ps --format '{{.Names}}') )
  local allRunning="true"
  if [[ ! " ${runningServicesArray[@]} " =~ " zookeeper " ]] #Zookeeper is shared between all environments
  then
    echo "Essential service zookeeper is not running$autoFixString"
    if string.equals $autoFix "true"
    then
      startZookeeper
    fi
    allRunning="false"
  fi

  for entry in "${ESSENTIAL_SERVICES_AND_COMMANDS[@]}" ; do
      service=${entry%%:*}
      startCommandName=${entry#*: }
      if [[ ! " ${runningServicesArray[@]} " =~ " $service$envString " ]]
      then
        echo "Essential service $service is not running$autoFixString"
        if string.equals $autoFix "true"
        then
          $startCommandName # start the service.
        fi

        allRunning="false"
      fi
  done

  if string.equals $allRunning "true"
  then
    echo "All essential services are running"
    return 0
  else
    # All services were not running, but may have been started now.
    if string.equals $autoFix "true"
    then
      if fastcheckessentialservices #check if services are running now
      then
        echo "Essential services were not running but have been fixed"
      else
        echo "Essential services could not be fixed"
      fi
    else
      return 1
    fi
  fi
}

function monitorServices() {
    while fastcheckessentialservices; do
      sleep 5
    done

    beep;beep
    say "Essential services have stopped"
}

function isdockerrunning() {
  if calledfromterminal
  then
    if (string.isnotemptyorblank $(command -v docker) && string.isnotemptyorblank $((docker ps 2> /dev/null) | grep -i "container"))
    then
      echo "Yes"
    else
      echo "No"
    fi
  else
    string.isnotemptyorblank $(command -v docker) && string.isnotemptyorblank $((docker ps 2> /dev/null) | grep -i "container")
  fi
}

function checkenv() {
  # 1. Check if docker is running.
  if isdockerrunning
  then
    echo "Docker is running"
  else
    echo "Docker is NOT running"
    return 1
  fi

  # 2. Check if all essential services are running.
  if ! fastcheckessentialservices
  then
    return 1
  fi

  # 3. Check if Onshape Server and grunt quickServe are running
  if ! areserversrunning
  then
    return 1
  fi

  # Success, everything seems to be working fine.
  return 0
}

function fixessentialservices() {
  fastcheckessentialservices "true" #auto-fix
}

function fixenv() {
  if ! isdockerrunning
  then
    startDockerApp
  fi

  fixessentialservices

  startserversifnotalready

  if isdebuggingdrawings
  then
    startDrawingDocker skipupdate
  fi
}

function stopenv() {
  # Stop Onshape server and grunt quickServe
  stopservers
  # Stop all Docker services
  stopallservices
  # Finally, stop Rancher Desktop itself.
  system.killallwithname "Rancher Desktop"
}

function getEnvNumber() {
  if string.isnotemptyorblank $HOST_PROPERTIES_ENVNUM
  then
    echo $HOST_PROPERTIES_ENVNUM
  else
    echo "0"
  fi
}

function monitorenv() {
  export MONITORING_ENV="true"
  local wasWorkingBefore="false"

  while checkenv; do
    echo ""
    echo $(system.getcurrentdate)
    wasWorkingBefore="true"
    sleep 5
  done

  unset MONITORING_ENV

  if string.equals $wasWorkingBefore "true"
  then
    beep;beep
    local message="Something has crashed in Environment $(getEnvNumber)"
    echo $message
    say $message
    return 1
  else
    echo "Environment check failed."
    return 1
  fi
}

function declareEssentialServices() {
  # This if else is in this form mostly because I don't know how to dynamically add
  # just one element in the array :), but it's ok for now.
  ESSENTIAL_SERVICES_AND_COMMANDS=("memcached: startMemcache" "mongod_7.0: startMongod" "rabbitmq: startRabbitMQServer")
  if isdebuggingdrawings
  then
    ESSENTIAL_SERVICES_AND_COMMANDS=("memcached: startMemcache" "mongod_7.0: startMongod" "rabbitmq: startRabbitMQServer" "xenon: startDrawingDocker")
  fi
}

function setdebuggingdrawings() {
  local DEBUGGING_DRAWINGS=$1
  if string.isemptyorblank $DEBUGGING_DRAWINGS
  then
    DEBUGGING_DRAWINGS="true"
  fi
  local extension=$(getEnvNumber)
  system.writevartodisk DEBUGGING_DRAWINGS $extension
}

function isdebuggingdrawings() {
  local envNum=$(getEnvNumber)
  local DEBUGGING_DRAWINGS=$(system.readvarfromdisk DEBUGGING_DRAWINGS $envNum)
  system.readvarfromdisk DEBUGGING_DRAWINGS $extension
  string.equals $DEBUGGING_DRAWINGS "true"
}

function getbsservers() {
  ps -ef | grep "BSServer" | grep "$STAGE/" | awk '{print $2}'
}

function restartbelcad() {
  fstopbelcad

  if ! isdockerrunning
  then
    startServices
  fi

  startbelcad
}

function restartquickserve() {
  fstopquickserve
  grunt quickServe
}

function beep() {
  tput bel
}

# Only works on mac by default (No linux support)
function playfinishsound() {
  beep;beep
  if string.isemptyorblank $1
  then
    say "Build Complete"
  else
    say "$1"
  fi
}

function buildgradleparallel() {
  # Not being in newton directory has caused problems too many times while building
  ensurenewtondirectory

  # Same goes with docker not running
  if ! isdockerrunning
  then
    startServices # Will ensure docker and services run
  fi

  gradle --parallel $@
  if system.waslastcommandsuccessful
  then
    playfinishsound "Build successful"
    # If the build was successful, and a handler is defined, call it now.
    if system.functionexists onsuccessfulbuild
    then
      onsuccessfulbuild & >/dev/null # Fire the onsuccessfulbuild function async.
    fi
    return 0
  else
    playfinishsound "Build failed"
    return 1
  fi
}

# There's no reason to keep merged branches
# but we can keep for a few days just for reference purposes
function markbranchmerged() {
  local branchname=$1
  if string.isemptyorblank $branchname
  then
    branchname=$(git.getcurrentbranch)
  fi
  local curdatetime=$(system.getcurrentdate)
  git.renamebranch $branchname merged/$branchname/$curdatetime
}

function markbranchreopened() {
  local oldbranchname=$1
  if string.isemptyorblank $branchname
  then
    oldbranchname=$(git.getcurrentbranch)
  fi

  local newbranchname=$(string.simplereplace $oldbranchname "merged/" "")
  local bugNumber=$(git.getbugnumberfrombranch $oldbranchname)
  bugNumber=$(string.tolower "$bugNumber")
  newbranchname=$(string.simplereplace $newbranchname "$bugNumber/" "$bugNumber/reopened/")
  git.renamebranch $oldbranchname $newbranchname
}

function markbrancharchived() {
  local branchname=$1
  if string.isemptyorblank $branchname
  then
    branchname=$(git.getcurrentbranch)
  fi
  git.renamebranch $branchname archived/$branchname
}

function createlsbreleasebranchfromlsbmastertopchange() {
  if ! git.branchislsbmasterbased
  then
    echo "It's not an lsb/master based branch. Please check the branch name again."
    return
  fi

  local topSHAId=$(git.getlatestcommitid)
  local currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbrelease $(getnewbranchname $currentbranch $LSB_CURRENT_RELEASE)
  git cherry-pick $topSHAId
}

function createrevertmasterbranchfrombranchtopchange() {
  local topSHAId=$(git.getlatestcommitid)
  local currentbranch=$(git.getcurrentbranch)
  checkoutfrommaster "$currentbranch-revert"
  git revert -m 1 $topSHAId
}

function createlsbmasterbranchfromlsbreleasetopchange() {
  if ! git.branchislsbreleasebased
  then
    echo "It's not an lsb/release based branch. Please check the branch name again."
    return
  fi
  local topSHAId=$(git.getlatestcommitid)
  local currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbmaster $(getnewbranchname $currentbranch $LSB_MASTER)
  git cherry-pick $topSHAId
}

function mergetomaster() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi

  if git.isoneoftheofficialbranches
  then
    echo "Wrong branch. You should call it on your feature branch and not on one of the official branches"
    return
  fi

  if ! git.branchislsbmasterbased && ! git.branchismasterbased
  then
    echo "Branch is not lsb/master or master based. Please check and try again"
    return
  fi

  # Check if a specific rbcommons review request id is given
  # Search for an approved request for the current git branch if not.
  if string.isemptyorblank "$1" && ! isreverting # If reverting we don't need to pull review request id
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetomaster $reviewrequestid
    fi
  else
    currentbranch=$(git.getcurrentbranch)
    rebaselatestbranch "master"
    if ! system.waslastcommandsuccessful
    then
      echo "Rebase didn't succeed. Please manually rebase/pull latest master branch and try again."
      return
    fi

    waitforenterkey "Press enter if and when rebase is successful to continue to merge to master"
    git checkout master
    if ! system.waslastcommandsuccessful
    then
      echo "git checkout failed, did not merge to master"
      return
    fi

    if isreverting
    then
      echo "Calling  mergepush $currentbranch --no-review -m \"$1\""
      mergepush "$currentbranch" --no-review -m "$1" # In this case the first argument is the revert comment.
      if system.waslastcommandsuccessful
      then
        setnotreverting
      fi
    else
      local cmd="mergepush $currentbranch -r $1"
      echo "Calling $cmd"
      mergepush $currentbranch -r $1
      if system.waslastcommandsuccessful
      then
        # Not really required, but mark the branch as merged.
        git checkout $currentbranch
        # rename the current branch as 'merged' to keep for a few days
        markbranchmerged $currentbranch
      else
        echo "mergepush was not succecsful, please call it again on the master."
      fi
    fi
  fi
}

# Revert a branch you merged to master. You should be on the branch
# to revert for calling this.
# Please make sure all the changes you did are in a single top
# commit in this branch (Squash changes first if that's not the case)
function revertbranchfrommaster() {
  local revertcomment="$1"
  if string.isemptyorblank "$revertcomment"
  then
    echo "Please enter a revert comment in quotes as input to this command (try again)."
    return
  fi

  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi

  if git.isoneoftheofficialbranches
  then
    echo "Wrong branch. You should call it on your feature branch and not on one of the official branches"
    return
  fi

  if ! git.branchislsbmasterbased && ! git.branchismasterbased
  then
    echo "Branch is not lsb/master or master based. Please check and try again"
    return
  fi

  waitforenterkey "Press enter to proceed only if there are no FeatureScript changes. If there are, press Ctrl+C and do it manually."

  git log -n 3
  waitforenterkey "Press enter if all of your changes are in one top commit, and ready to create the revert branch from it (Otherwise press Ctrl+C and try again after squashing them to one change, or do manually)."
  createrevertmasterbranchfrombranchtopchange

  if ! system.waslastcommandsuccessful
  then
    echo "Revert has merge problems. Resolve those, and then merge the branch to master using mergetomaster"
    return
  fi

  waitforenterkey "Press enter if the revert commit was successful, else press Ctrl+C and mergetomaster later."
  setreverting
  mergetomaster "$revertcomment"
}

function setreverting() {
  export REVERTING_CHANGES=1
}

function isreverting() {
  string.isnotemptyorblank $REVERTING_CHANGES
}

function setnotreverting() {
  unset REVERTING_CHANGES
}

function setnoresolve() {
  export RBCOMMONS_NO_RESOLVE=1
}

function mergetoreleasethenmaster() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to release"
    return
  fi

  if git.isoneoftheofficialbranches
  then
    echo "Wrong branch. You should call it on your feature branch and not on one of the official branches"
    return
  fi

  # Fetch the latest release branch from the server
  refreshcurrentreleasebranch

  waitforenterkey "Will merge to release branch : $CURRENT_RELEASE. Press enter if that's correct, else press Ctrl+C to terminate this function, call 'export CURRENT_RELEASE=rel-<correct-version>' without single quotes and call this function again."

  local currentbranch=$(git.getcurrentbranch)

  if ! (string.endswith $currentbranch "-rel-[0-9].[0-9]*")
  then
    if git.branchislsbmasterbased
    then
      # Try automatically creating lsb/release based branch of it with the top commit.
      git log -n 3
      waitforenterkey "lsb/master based branch found. Press enter if all of your changes are in one top commit, and ready to create lsb/release branch off it (Otherwise press Ctrl+C and try again later)."
      createlsbreleasebranchfromlsbmastertopchange
      waitforenterkey "Press enter if the lsb/release branch creation and cherry picking from source branch commit was successful, otherwise either resolve merge issues in another tab before pressing enter here, or press Ctrl+C to terminate operation and do it all manually."
      currentbranch=$(git.getcurrentbranch)
      echo "Created branch $currentbranch from the lsb/master based branch with the same commit"
    else
      echo "Branch does not end with a -rel-x.y* pattern. Please check and run manually"
      return
    fi
  fi

  if string.isemptyorblank $1
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetoreleasethenmaster $reviewrequestid
    fi
  else
    reviewrequestid=$1
    # Merge to release first

    rebaselatestbranch $CURRENT_RELEASE

    if ! system.waslastcommandsuccessful
    then
      echo "Rebase didn't succeed. Please manually rebase/pull latest master branch and try again."
      return 1
    fi

    waitforenterkey "Press enter if and when rebase is successful to continue to merge to release, otherwise press Ctrl+C and do it manually"
    git checkout $CURRENT_RELEASE
    echo "Calling mergepush $currentbranch -r $reviewrequestid"
    mergepush $currentbranch -r $reviewrequestid

    if ! system.waslastcommandsuccessful
    then
      echo "mergepush didn't succeed. Please manually resolve the problem and try again."
      return 1
    fi

    # Merge changes back to master
    waitforenterkey "Merging changes to master now, press enter when ready"
    checkoutfrommaster $currentbranch # Will create new branch from master taking name from $currentbranch

    #Rename the last branch before reassigning the variable to the current one.
    markbranchmerged $currentbranch

    currentbranch=$(git.getcurrentbranch)
    git merge $CURRENT_RELEASE

    if ! system.waslastcommandsuccessful
    then
      waitforenterkey "Merging release into master was NOT successful. Please resolve merge issues in another tab and then press enter here to continue, or press Ctrl+C and carry remaining steps manually."
      waitforenterkey "Just double checking. You are sure the merge issues are resolved in another tab? Press enter if yes, or Ctrl+C to quit from here and do rest of the steps manually."
    fi

    # Validate that only your commits are included. If you see more than your changes here, wait for other authors to push  theirs, do pullmerge master after that or ask them if it is OK to push the changes to master.
    git log --format="%an: %s" master..$currentbranch

    waitforenterkey "Press enter if you see only your commits above, otherwise press Ctrl+C and do it manually"

    git checkout master
    mergepush $currentbranch -r $reviewrequestid --no-resolve # don't resolve the bug again, so fixed-in hash keeps pointing to the rel branch

    git checkout $currentbranch
    markbranchmerged $currentbranch
  fi
}

function startDockerApp() {
  if isdockerrunning
  then
    echo "Docker is already running"
    return
  fi

  # [2023/11/01] : We use Rancher Desktop now instead of Docker Desktop
  if system.commandsucceeds $(open -a /Applications/Rancher\ Desktop.app)
  then
    # Give Docker some time to get initialized, otherwise
    # starting services fails.
    echo -n "Docker started, waiting for it to be ready"
    while (! docker stats --no-stream > /dev/null 2>&1 ); do
      echo -n "."
      sleep 1
    done
    echo "" # print a newline character
  else
    echo "Can't open Docker app"
    return
  fi
}

# Start required services for the Onshape server
# and newton to run (not the server itself, use
# startservers for that). Also starts Docker
# is not already running.
function startServices() {
  if ! isdockerrunning
  then
    echo "Starting Docker process as it was not found to be running"
    startDockerApp
  else
    echo "Docker found to be running"
  fi
  # Actually start the services now when Docker is confirmed to be running
  btEnvUp
}

# Starts both the Onshape (belcad) server
# and calls grunt quickServe to
function startservers() {
  if ! isdockerrunning
  then
    # startServices is supposed to start
    # Docker as well if not running
    startServices
  fi

  startbelcad
  if ! system.waslastcommandsuccessful
  then
    echo "Error: Could not start Onshape server. Not starting quickServer"
    return
  fi

  grunt quickServe
}

# Start onshape server and grunt quickServe only if they
# are not already running.
function startserversifnotalready() {
  if ! isdockerrunning
  then
    # startServices is supposed to start
    # Docker as well if not running
    startServices
  fi

  if isonshapeserverrunning
  then
    echo "Onshape server is already running"
  else
    echo "Onshape server not already running, starting it now"
    startbelcad
    if ! system.waslastcommandsuccessful
    then
      echo "Error: Could not start Onshape server. Not starting quickServer"
      return
    fi
  fi

  if isquickserverunning
  then
    echo "quickServe is already running"
  else
    echo "quickServe is not already running, starting it now"
    grunt quickServe
  fi
}

function stopservers() {
  fstopbelcad "nosleep"
  fstopquickserve
}

function restartservers() {
  stopservers
  startservers
}

function buildall() {
  cd $REPO_NEWTON
  buildgradleparallel
}

function buildjavaonly() {
    export SKIP_DRAWING=1
    export SKIP_CPP=1
    export SKIP_JSLIB=1
    buildgradleparallel
    local returnvalue=$?
    unset SKIP_CPP
    unset SKIP_JSLIB
    unset SKIP_DRAWING

    return $returnvalue
}

function buildjsonly() {
    export SKIP_DRAWING=1
    export SKIP_CPP=1
    export SKIP_JAVA=1
    # In some cases you might have made a change to the serializable
    # classes and would need to generate new serializable code that's
    # applicable to JS code, but that's still Java code and it's understood
    #  that for that you'd either buildjava, OR generate serializables separately
    # using the `genser` command
    export SKIP_SERIALIZABLES=1
    buildgradleparallel -x runBtUpgrade
    local returnvalue=$?
    unset SKIP_CPP
    unset SKIP_JAVA
    unset SKIP_DRAWING
    unset SKIP_SERIALIZABLES
    return $returnvalue
}

function buildcpponly() {
    export SKIP_DRAWING=1
    export SKIP_JSLIB=1
    export SKIP_JAVA=1
    export SKIP_SERIALIZABLES=1
    buildgradleparallel
    local returnvalue=$?
    unset SKIP_JSLIB
    unset SKIP_JAVA
    unset SKIP_DRAWING
    unset SKIP_SERIALIZABLES
    return $returnvalue
}

function buildjavaandjsonly() {
    export SKIP_DRAWING=1
    export SKIP_CPP=1
    buildgradleparallel
    local returnvalue=$?
    unset SKIP_CPP
    unset SKIP_DRAWING
    return $returnvalue
}

# Create a patch of all the committed/uncommitted changes
# and compare with the remote origin master / lsb/master
# CAUTION : Doesn't handle new files as of now. ToDo.
function patchallchanges() {
  echo "Refreshing tags..."
  git fetch origin --tags --force --prune
  local path=$(git.getpatchfilepath "$1")
  system.createfileifdoesnotexist $path
  git diff "$(getbasebranchname origin)" > "$path"
  echo "Patch file created at $path"
}

# Pass jira number
function openbug() {
  if string.isemptyorblank $1
  then
    echo "Bug number not provided"
    return
  fi

  local bugNumber=$1
  bugNumber=$(string.toupper $bugNumber)
  if string.isnumber $bugNumber
  then
    # Take BEL by default.
    bugNumber="BEL-$bugNumber"
  fi

  open "https://belmonttechinc.atlassian.net/browse/$bugNumber"
}

function createbugfolder() {
  if string.isemptyorblank $1
  then
    echo "Bug number not provided"
    return
  fi

  local bugNumber="$1"
  bugNumber=$(string.simplereplace $(string.tolower $bugNumber) "bel-" "")
  bugNumber="BEL-$bugNumber"
  mkdir "$HOME/Bugs/$bugNumber" > /dev/null 2>&1
}

function openbugfolder() {
  if string.isemptyorblank $1
  then
    echo "Bug number not provided"
    return
  fi

  local bugNumber="$1"
  bugNumber=$(string.simplereplace $(string.tolower $bugNumber) "bel-" "")
  bugNumber="BEL-$bugNumber"
  open "$HOME/Bugs/$bugNumber"
}


function ptortest() {
 ptor $1 --verbose --flags=fastFail --target=https://localhost.onshape.io:8000/
}

function pushtos3() {
  # Put a timestamp to the branch name and remove hyphen after bel from branch name
  # as otherwise kibana logs show the branch name only as "bel" and nothing else
  local originalbranchname=$(git.getcurrentbranch)
  local currentdatetime=$(system.getcurrentdate "_")
  currentdatetime=$(string.concatenate "$currentdatetime" "_")

  # Change bel-xxxxxx to bel_xxxxxx
  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  local newbranchname=$(echo $originalbranchname | sed -En "s,bel-([[:digit:]]+),bel_\1_$currentdatetime,p")
  # Change just a couple of hyphens to underscore for more info of the branch name to show up in elastic search
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  #echo $originalbranchname
  #echo $newbranchname
  git.renamecurrentbranch $newbranchname
  pushToBuildFarm @promote-to-s3-test
  # After it's done, change the branch name back to original
  git.renamecurrentbranch $originalbranchname
}

# Function for visualizing timer.log times. Call this followed by opening
# localhost:8088 page in the browser. Visit https://github.com/onshape/timerdisplay
# for more details
function runTimerDisplay() {
  cd $HOME/repos/timerdisplay
  sleep 5 && open "http://localhost:8088" & # Delay launch the webpage :).
  ./server.js -p 8088 $STAGE/WebSvc/logs/timer.log --debug
}

# Remove from work (Better suited for personal profile)?
# Quickly create or update a dummy branch that's based on latest
# lsb/master. For those non-ideal times you need lsb/master as a branch
# and not as a tag.
function updatedummylsbmaster() {
  # Store current branch
  local currentbranch=$(git.getcurrentbranch)
  local dummybranchname=$(getnewbranchname "dummy" "lsb/master")
  local alreadyindummybranch="false"
  if git.localbranchexists $dummybranchname
  then
      if ! string.equals $currentbranch $dummybranchname
      then
        git checkout "$dummybranchname"
      fi
      pulllatest
  else
    echo "Updating $dummybranchname with latest lsb/master"
    checkoutfromlsbmaster "dummy"
  fi

  if ! string.equals $currentbranch $dummybranchname
  then
    echo "Checking out previous branch again"
    git checkout $currentbranch
  fi
}

alias bfnodestop='bf job rm'
alias bfjobremove='bfnodestop'
alias bsserverpath="$STAGE/BSServer/bin/BSServer"
alias grdlbuildjavaonly='grdlu gen java' #Build java only, download binaries for others
alias grdlbuildjsonly='grdlu gen js' #Build javascript only, download binaries for others
alias grdlbuildjavaandjsonly='grdlu gen java js' #Build java and javascript only, download binaries for others
alias checknecessaryservices='checkessentialservices'
alias checkJsCode='grunt checkJsCode'
alias checkjs='grunt eslint:javascript'
alias checkts='grunt eslint:typescript'
# alias clion="open -a $HOME/Applications/JetBrains\ Toolbox/CLion.app"
alias cppbuild='buildcpponly'
alias dockerclean='cleandocker'
alias droptoproduction='mongoDropToProduction'
alias eclipse='open -a /Applications/Eclipse.app'
alias eslintfix='grunt eslint:fix'
alias fixgruntnotfound='fixDiskImagesJS'
alias fixjs='grunt eslint:fix'
alias fixts='grunt eslint:fix'
alias fixpo='grunt xgettext --fix'
alias generateserializables='grunt generateSerializables'
alias genser='grunt generateSerializables'
alias gitlistskipignoredfiles='git ls-files -v . | grep ^S'
alias gruntQuickServe='grunt quickServe'
alias inteli='intellij'
alias intellij='idea' #Jetbrains Toolbox generates the script 'idea' for version dependent IntelliJ IDEA
alias jira='openbug'
alias openjira='jira'
alias javabuild='buildjavaonly'
alias jsbuild='buildjsonly'
alias jumpboxaddstaticroute='addstaticroutetojumpbox'
alias jumpboxnetstat='netstat -rn | grep 52.210.113.201'
alias jumpboxssh='sshjumpbox'
alias localprecommit='yarn precommit'
alias lsbreleasecheckout='checkoutfromlsbrelease'
# alias mergelatestmaster='pullmerge master'
alias mongodump='mongoDump'
alias mongobackup='mongoDump'
alias mongorestore='mongoRestore'
alias backupmongo='mongoDump'
alias restoremongo='mongoRestore'
alias newton='cd $REPO_NEWTON'
alias kibanatools='cd $DEV_TOOLS/kibanaTools'
alias pofix='fixpo'
alias prepeclipse='gradle prepEclipse'
alias prepclion='gradle :cpp:prepCLion --parallel'
alias protractortest='ptortest'
alias runprotractortest='ptortest'
alias runptortest='ptortest'
# alias pullmaster='pullmerge master'
# alias pullmergemaster='pullmerge master'
alias pushtobuild='pushToBuildFarm @precommit @uitest @mocha'
alias quickserve='grunt quickServe'
# alias rebasemaster='pullmerge master --rebase'
alias serial='grunt generateSerializables'
alias serialize='grunt generateSerializables'
alias setisreverting='setreverting'
alias sshjumpbox="ssh -X $USER@jumpbox-primary.dev.onshape.com"
alias startenv='startServices;startservers';
alias startquickserve='quickserve'
alias staging='cd $STAGE'
alias starttimerdisplay='runTimerDisplay'
alias stopServices='btEnvDown'
alias startallservers='startservers'
alias restartServices='stopallservices;startServices'
alias startfrontend='grunt quickServe'
alias timerdisplay='runTimerDisplay'
alias updaterbt='rbtupdate'
alias xcode='open -a Xcode.app $STAGE/build/cppServer/DebugXcodeCCache/BTcppServer.xcodeproj/'
alias web='webstorm'
alias webs='webstorm'
alias storm='webstorm'
alias productionretrievalconfigfile='$STAGE/ModelingSvc/webapps/root/WEB-INF/config/applicationContext.xml'
alias openbtserver='openbtserverweblog'
alias isbelcadrunning='isonshapeserverrunning'
alias opentimerlog='opentimerlogweb'
