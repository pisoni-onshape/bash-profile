#!/bin/bash
shopt -s expand_aliases

# Official exports:
# -----------------
# CPP compiler cache
export USE_CCACHE=1

# Debug cpp build
export RELEASE=0

# Measure load times in viewer (can view in timer.log)
export BTI_ENABLE_TIMERS=1

# So that BSServer doesn't time out so early
export BTI_DISABLE_HEARTBEATS=1

# So that thumbnails are generated in the dev environment (off by default)
# Remove if not needed.
export ENABLE_THUMBNAIL_SERVICE=1

# If debugging BSServer, cut down on the number of BSServers available to attach to
# ****** CAUTION: REMOVE WHEN WORKING WITH THUMBNAILS, otherwise it won't create Thumbnail
# cpp server pool ******
#export BTI_BLOCK_THUMBNAIL_CPP_SERVER_POOL=1

# Remove unnecessary deprecation warning
export BASH_SILENCE_DEPRECATION_WARNING=1

# Improve artifactory download performance from S3, but sometimes causes other problems. Use only when
# facing problem with the default region (which is typically us-west-2)
#export OBJECT_STORE_REPO_REGION=ap-south-1

#export HOST_PROPERTIES_PRIVATEIP="$(dockerCreateLoopbackAlias)"
# This is only an issue if you usually extract std from stacks and upgrade has to process lot of std versions
# In that case, there might be out of memory problems while building java
export UPGRADE_MAX_MEMORY_GB=8
export JAVA_MAX_MEMORY_MB=8192
# Use jaeger for local tracing instead of SignalFx:
export DEV_SIGNALFX_TRACING=2
# Dev Tools Path
export DEV_TOOLS=$HOME/repos/onshape-dev-tools

# Others
#set -o nounset # Make the script fail if trying to access an unset variable.


# Ensure we're in the newton
# or one of its subdirectories.
function ensurenewtondirectory() {
  if string.isemptyorblank $REPO_NEWTON
  then
    # Should be the case when we've just started the Terminal.
    cd $HOME/repos/newton
    source buildenv.bash
  elif ! string.contains $(pwd) $REPO_NEWTON
  then
    # $REPO_NEWTON is initialized but we're not in it or one of its subdirectories
    cd $REPO_NEWTON
  fi
}

# This should also source buildenv.bash the first time it's opened
ensurenewtondirectory

# Unofficial exports
# ------------------
# Now when the environment should be set, some exports used by this script:
export CURRENT_RELEASE=rel-1.157
export LSB_MASTER=lsb/master
export LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE
export GIT_MERGE_AUTOEDIT=no
export RETRIEVAL_REPORT_WRITE_TO_DISK=1
export PATH="$HOME/Library/Python/3.8/bin:${PATH}" # Mostly so that 'rbt' works.
export btserverwebpath="$STAGE/WebSvc/logs/btserver.log"
export btservermodpath="$STAGE/ModelingSvc/logs/btserver.log"
export timerlogwebpath="$STAGE/WebSvc/logs/timer.log"
export timerlogmodpath="$STAGE/ModelingSvc/logs/timer.log"
export upgradelogwebpath="$STAGE/WebSvc/logs/upgrade.log"
# Sometimes, for some reason the logs go in the logsDir_IS_UNDEFINED directory
# No one seems to know the exact reason at the time of writing this.
export undefinedbtserverwebpath="$STAGE/WebSvc/logsDir_IS_UNDEFINED/btserver.log"
export undefinedtimerlogwebpath="$STAGE/WebSvc/logsDir_IS_UNDEFINED/timer.log"


# Import Utility modules
importutility string
importutility system
importutility git
importutility rbt
importutility general


# Set CPP builder according to the platform
function platformspecificsettings() {
  if system.ismacos
  then
    echo "Detected macOS, using XCODEBUILD"
    unset CLIONBUILD
    export XCODEBUILD=1
  else # Assume Linux for now.
    echo "Using CLIONBUILD for building C++"
    unset XCODEBUILD
    export CLIONBUILD=1
  fi
}

# Make a call to it here itself
platformspecificsettings

function setrelease() {
  if string.equals $1 "0"
  then
    export RELEASE=0
    echo "Set to build in debug mode"
  else #empty or any other argument.
    export RELEASE=1
    echo "Set to build in release mode"
  fi
}

function setdebug() {
  if string.equals $1 "0"
  then
    export RELEASE=1
    echo "Set to build in release mode"
  else #empty or any other argument.
    export RELEASE=0
    echo "Set to build in debug mode"
  fi
}

# INCOMPLETE function. Find next onshape version given the input version
# Or a few versions forward or backward if a second +/- integer is sent
# to add to it
function newonshapeversion() {
  local original=$1
  local addition=1
  if ! string.isemptyorblank $2
  then
    addition=$2
  fi

  # Trim everything before "."
  local prefix=$(string.simplereplace "$original" ".*" "")
  # Trim everything before "."
  local version=$(string.simplereplace "$original" "*." "")
  local newsuffix=$(general.add $version $addition)
  echo "$prefix.$newsuffix"
}

function refreshcurrentreleasebranch() {
  local currentrelease="rel-$NEWTON_VERSION"
  echo "Refreshing CURRENT_RELEASE (pulling from the server) ..."
  # The current release can only either be the current
  # newton version, or one before it.
  if git.remotebranchexists $currentrelease
  then
    CURRENT_RELEASE=$currentrelease
  else
    CURRENT_RELEASE=$(newonshapeversion $currentrelease -1)
  fi

  # Refresh the current lsb release branch as well.
  LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE

  echo "CURRENT_RELEASE set to $CURRENT_RELEASE"

  # if system.fileexists "$BASH_PROFILE_PATH/.currentrelease"
  # then
  #   currentrelease=$(<$BASH_PROFILE_PATH/.currentrelease)
  # fi
}

function debugstaging() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://staging.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugdemoc() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://demo-c.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugproduction() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://cad.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function fixDiskImagesJS() {
  diskImageUmountAll
  rm $BUILD_TOOLS/diskimage/onshape-javascript_*
  source buildenv.bash
}

function importextractedfile() {
  waitforenterkey "If the file doesn't include std, make sure you've run 'mongoDropToProduction' and 'gradle runBtUpgrade' before this (press enter if yes, and Ctrl+C if you haven't)"
  restoreDump "$1" --nodrop --remap=btadmin@onshape.com
}

function runupgrade() {
  gradle runDocumentUpgrade -Donshape.upgrade.exitwhenfinished=true
}

function runretrieval() {
  if string.isemptyorblank $1
  then
    echo "A numeric Jenkins build id is required"
    return
  fi

  # If there's a second argument specified, take it as the documentidregex string
  # input to the retrieval service (which you should ideally pass without spaces,
  # as I haven't tested what will happen with spaces in these arguments :) )
  if string.isemptyorblank $2
  then
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1
  else
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1 -Donshape.productionretrieval.documentidregex=$2
  fi
}

function makelikeproduction() {
  #Make sure Docker is running, and mongo service is running as well
  mongobackup
  stopbelcad
  mongoDropAll
  mongoDropToProduction
  export SKIP_INTERNAL_MODULES=1
}

function makelikeproductionwithbuild() {
  makelikeproduction
  buildgradleparallel
}

function openconfigpropertiesjson() {
  texteditor $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
}

function openupgradelogweb() {
  edit $upgradelogwebpath
}

function openbttimerlogweb() {
  edit $timerlogwebpath
}

function openbtserverweblog() {
  texteditor $btserverwebpath
}

function openbtservermodlog() {
  texteditor $btservermodpath
}

function opentimerlogweb() {
  texteditor $timerlogwebpath
}

function opentimerlogmod() {
  texteditor $timerlogmodpath
}

function cleanbtserverweblog() {
  system.cleanfilecontents "$btserverwebpath"
}

function cleanbtservermodlog() {
 system.cleanfilecontents "$btservermodpath"
}

function cleanlogs() {
  # These should not be needed and aren't even used in normal cases,
  # but sometimes our logs go into the logsDir_IS_UNDEFINED directory
  # for some reasons.
  if system.fileexists "$undefinedtimerlogwebpath"
  then
    system.cleanfilecontents "$undefinedtimerlogwebpath"
  fi

  if system.fileexists "$undefinedbtserverwebpath"
  then
    system.cleanfilecontents "$undefinedbtserverwebpath"
  fi

  cleanbtserverweblog
  cleanbtservermodlog
  system.cleanfilecontents "$timerlogwebpath"
  system.cleanfilecontents "$timerlogmodpath"
  system.cleanfilecontents "$upgradelogwebpath"
}

function setupforproductionretrieval() {
  # First make your environment 'like' production (though that might not be necessary to just 'run' and debug the code)
  #makelikeproduction
  echo "setting SKIP_INTERNAL_MODULES to 1"
  export SKIP_INTERNAL_MODULES=1
  openconfigpropertiesjson
  echo "Change the defaultValue of productionretrieval.write-s3 from false to true in the opened config-properties.json"
  waitforenterkey "Press enter when done"
  echo "Build (gradle) manually now using buildgradleparallel"
  #buildgradleparallel
  #waitforenterkey "Press enter when done"
  echo "call runupgrade to run document upgrade"
  #runupgrade
  #waitforenterkey "Press enter when upgrade has been done"
  echo "You can now see upgrade logs in $STAGE/ModelingSvc/logs/btserver.log"
  echo "Also, the upgrade data should be written to $STAGE/MockS3/onshape-myregion/test/operations/myenv/regen-data"
  #open "$STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  echo "Finally, run the local production retrieval process by calling runretrieval"
  #runretrieval
}

function waitforenterkey() {
  read -p "$1"
}

function runjunittest() {
    gradle safelyRunSpecificTests -Dtest=$1
}

function awsconfigure() {
  btAws configure --profile codebuild
}

function checkpmd() {
  gradle :java:pmd
}

function myprecommit() {
  # Remove this first line once yarn precommit starts catching
  # typescript errors again
  #npx tsc --noEmit --project $REPO_NEWTON/project/web/tsconfig.json
  checkTidy
  checkpmd
  grunt checkJsCode
}

function addstaticroutetojumpbox() {
  sudo route -n add 54.187.217.158/32 $1
}

function getnewbranchname() {
  local inputbranchname=$(string.tolower $1)
  local targetbranch=$(string.tolower $2)
  if ! (string.beginswith $inputbranchname "$USER/")
  then
    inputbranchname=$USER/$inputbranchname
  fi

  # Remove all lsb-release, lsb-master, -master, rel- etc. suffixes from the branch  name
  inputbranchname=$(string.simplereplace $inputbranchname "-lsb-*" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-master" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-release" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-rel-[1-9]*" "")
  if string.isnotemptyorblank $targetbranch
  then
    targetbranch=$(string.simplereplace $targetbranch "/" "-")
    inputbranchname=$inputbranchname-$targetbranch
  fi

  echo $inputbranchname
}

function checkoutfrommaster() {
  ensurenewtondirectory
  git checkout master
  git pull
  git checkout -b $(getnewbranchname $1 "master")
  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromrelease() {
  ensurenewtondirectory
  git checkout $CURRENT_RELEASE
  git pull
  git checkout -b $(getnewbranchname $1 $CURRENT_RELEASE)
  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromlsbbranch() {
  if string.isemptyorblank $1
  then
    echo "Please provide new branch name"
  elif string.isemptyorblank $2
  then
    echo "Please provide the base branch name"
  else
    gitBranchLsb $(getnewbranchname $1 "lsb/$2") $2
  fi

  latestcreatedbranch=$(git.getcurrentbranch)
}

function checkoutfromlsbmaster() {
  ensurenewtondirectory
  checkoutfromlsbbranch "$1" "master" #lsb/ is eventually appended by gitBranchLsb
}

function checkoutfromlsbrelease() {
  ensurenewtondirectory
  checkoutfromlsbbranch "$1" "$CURRENT_RELEASE" #lsb/ is eventually appended by gitBranchLsb
}

function rebaselatest() {
  pulllatest "rebase"
}

# Unless otherwise specified, default branch for rbt is master
function pulllatest() {
  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Rebasing w.r.t. to that"
    pulllatestbranch "$LSB_MASTER" $1 # Assuming $1 would be "rebase" when needed (e.g. called from rebaselatest), and empty otherwise
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Rebasing w.r.t. to that"
    pulllatestbranch "$LSB_CURRENT_RELEASE" $1
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Rebasing w.r.t. to that"
    pulllatestbranch "master" $1
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Rebasing w.r.t. to that"
    pulllatestbranch "$CURRENT_RELEASE" $1
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based rebase"
    pulllatestbranch "master" $1
  fi
}

function rebaselatestbranch() {
  pulllatestbranch $1 "rebase"
}

function pulllatestbranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  else
    local argument=""
    if string.contains "$2" "rebase" || string.equals "$2" "-r"
    then
      argument="--rebase"
    fi

    echo "Calling pullmerge $1 $argument"
    pullmerge "$1" $argument
    if system.lastcommandwassuccessful
    then
      echo "$USER: pullmerge successful"
    else
      echo "$USER: pullmerge failed"
    fi
  fi
}

# rbt post and updates
function rbtpostfrombranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  else
    echo "Calling rbt post -o $1...HEAD"
    rbt post -o $1...HEAD
  fi
}

# Unless otherwise specified, default branch for rbt is master
function rbtpost() {
  ensurenewtondirectory

  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch "master"
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Creating diff w.r.t. to that"
    rbtpostfrombranch $CURRENT_RELEASE
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based diff"
    rbtpostfrombranch "master"
  fi
}

function rbtupdatefrombranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  elif string.isemptyorblank $2
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_ANY)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find a matching review request for the branch, enter manually."
    else
      echo "Automatically found review request id: $reviewrequestid for current branch"
      rbtupdatefrombranch $1 $reviewrequestid
    fi
  else
    echo "Calling rbt post -o -u -r $2 $1...HEAD"
    rbt post -o -u -r $2 $1...HEAD
  fi
}

# Unless otherwise specified, default branch for rbt is master
function rbtupdate() {
  ensurenewtondirectory

  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch "master"
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefrombranch $CURRENT_RELEASE
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based diff"
    rbtupdatefrombranch "master"
  fi
}

function rbtpostwithrebase() {
  rebaselatest
  rbtpost
}

function rbtupdatewithrebase() {
  rebaselatest
  rbtupdate
}

function testregex() {
  var1='rel-1'
  var2='rel-[0-9]*'
  if [[ 'rel-1' =~ 'rel-[0-9]*' ]]
  then
    echo yes
  else
    echo no
  fi

  check_dec='^rel-[0-9]\.[0-9]+'
  input=0

  echo "Please enter a digit: "
  read input

  if [[ $input =~ $check_dec ]]
  then
           echo "The value is a decimal"
  else
          echo "The value is something else"
  fi
}

function setupjumpboxcertificates() {
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.key /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:ca.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:tls-auth.key /tmp
}

# Prints an output (True/False) only when called
# directly from the Terminal (else returns true/false)
function isonshapeserverrunning() {
  local jettypid=$(ps -ef | grep jetty | grep -v grep | awk '{print $2}')
  if calledfromterminal
  then
    general.showtrueorfalse $(string.isnotemptyorblank $jettypid)
  fi

  string.isnotemptyorblank $jettypid
}

# Assumes pid to kill is a valid one
function killprocessid() {
  echo "Killing $2 PID $1"
  kill -9 $1

  if ! string.equals $3 "nosleep"
  then
    # Allow the process to be killed (I observed a couple of times that it doesn't immediately get killed
    # and the next command like system.whoisusingport8080 still shows that PID)
    sleep 2
  fi
}

# Test if a function is called directly
# from terminal or from another function.
function calledfromterminal() {
  #caller | awk '{print $2}'
  # ${FUNCNAME[2]} represents the caller name of *this* function.
  # Empty if caller was called directly from terminal.
  (string.isemptyorblank "${FUNCNAME[2]}")
}

function getquickservepid() {
  local pid=$(lsof -iTCP -n -P | grep node.*127\.0\.0\.1:8000.*LISTEN | awk '{print $2}')
  echo $pid
}

function isquickserverunning() {
  local pid=$(getquickservepid)
  if calledfromterminal
  then
    general.showtrueorfalse $(string.isnotemptyorblank $pid)
  fi

  string.isnotemptyorblank $pid
}

function fstopquickserve() {
  local pid=$(getquickservepid)
  if ! string.isemptyorblank $pid
  then
    killprocessid $pid "quickserve" $1 # this optional argument can be "nosleep"
  else
    echo "Didn't find quickserve process to kill"
  fi
}

function fstopbelcad() {
  # Consider using this instead, which is multi-env aware: checkServices -s websvc
  local jettypid=$(ps -ef | grep jetty | grep -v grep | awk '{print $2}')
  if ! string.isemptyorblank $jettypid
  then
    killprocessid $jettypid "jetty" $1 # this optional argument can be "nosleep"
  else
    echo "Didn't find jetty process to kill"
  fi
}

function restartbelcad() {
  fstopbelcad
  startbelcad
}

function beep() {
  tput bel
}

# Only works on mac by default (No linux support)
function playfinishsound() {
  beep;beep;
  if string.isemptyorblank $1
  then
    say "Build Complete"
  else
    say "$1"
  fi
}

function buildgradleparallel() {
  # Not being in newton directory has caused problems too many times while building
  ensurenewtondirectory

  # Same goes with docker not running
  if ! system.isprocessrunning "Docker"
  then
    echo "Docker is not running, please start it and try again."
    return
  fi

  gradle --parallel
  if system.lastcommandwassuccessful
  then
    playfinishsound "Build successful"
    # If the build was successful, and a handler is defined, call it now.
    if system.functionexists onsuccessfulbuild
    then
      onsuccessfulbuild & # Fire the onsuccessfulbuild function async.
    fi
  else
    playfinishsound "Build failed"
  fi
}

# There's no reason to keep merged branches
# but we can keep for a few days just for reference purposes
function markbranchmerged() {
  local branchname=$1
  if string.isemptyorblank $branchname
  then
    branchname=$(git.getcurrentbranch)
  fi
  git.renamebranch $branchname merged/$branchname
}

function markbrancharchived() {
  local branchname=$1
  if string.isemptyorblank $branchname
  then
    branchname=$(git.getcurrentbranch)
  fi
  git.renamebranch $branchname archived/$branchname
}

function createlsbreleasebranchfromlsbmastertopchange() {
  if ! git.branchislsbmasterbased
  then
    echo "It's not an lsb/master based branch. Please check the branch name again."
    return
  fi

  local topSHAId=$(git.getlatestcommitid)
  local currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbrelease $(getnewbranchname $currentbranch $LSB_CURRENT_RELEASE)
  git cherry-pick $topSHAId
}

function createlsbmasterbranchfromlsbreleasetopchange() {
  if ! git.branchislsbreleasebased
  then
    echo "It's not an lsb/release based branch. Please check the branch name again."
    return
  fi
  local topSHAId=$(git.getlatestcommitid)
  local currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbmaster $(getnewbranchname $currentbranch $LSB_MASTER)
  git cherry-pick $topSHAId
}

function mergetomaster() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi

  if git.isoneoftheofficialbranches
  then
    echo "Wrong branch. You should call it on your feature branch and not on one of the official branches"
    return
  fi

  if ! git.branchislsbmasterbased && ! git.branchismasterbased
  then
    echo "Branch is not lsb/master or master based. Please check and try again"
    return
  fi

  # Check if a specific rbcommons review request id is given
  # Search for an approved request for the current git branch if not.
  if string.isemptyorblank $1
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetomaster $reviewrequestid
    fi
  else
    currentbranch=$(git.getcurrentbranch)
    rebaselatestbranch "master"
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to master"
    git checkout master
    if ! system.lastcommandwassuccessful
    then
      echo "git checkout failed, did not merge to master"
      return
    fi

    echo "calling mergepush $currentbranch -r $1"
    mergepush $currentbranch -r $1
    git checkout $currentbranch
    # rename the current branch as 'merged' to keep for a few days
    markbranchmerged $currentbranch
  fi
}

# Not used right now. The idea is
# that it should pick this variable and
# call --no-review --no-resolve to mergepush
# automatically
function setreverting() {
  export REVERTING_CHANGES=1
}

function setnoresolve() {
  export RBCOMMONS_NO_RESOLVE=1
}

function mergetoreleasethenmaster() {
  ensurenewtondirectory

  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to release"
    return
  fi

  if git.isoneoftheofficialbranches
  then
    echo "Wrong branch. You should call it on your feature branch and not on one of the official branches"
    return
  fi

  # Fetch the latest release branch from the server
  refreshcurrentreleasebranch

  waitforenterkey "Will merge to release branch : $CURRENT_RELEASE. Press enter if that's correct, else press Ctrl+C to terminate this function, call 'export CURRENT_RELEASE=rel-<correct-version>' without single quotes and call this function again."

  local currentbranch=$(git.getcurrentbranch)

  if ! (string.endswith $currentbranch "-rel-[0-9].[0-9]*")
  then
    if git.branchislsbmasterbased
    then
      # Try automatically creating lsb/release based branch of it with the top commit.
      git log -n 3
      waitforenterkey "lsb/master based branch found. Press enter if all of your changes are in one top commit, and ready to create lsb/release branch off it (Otherwise press Ctrl+C and try again later)."
      createlsbreleasebranchfromlsbmastertopchange
      waitforenterkey "Press enter if the lsb/release branch creation was successful, otherwise press Ctrl+C and try again later."
      currentbranch=$(git.getcurrentbranch)
      echo "Created branch $currentbranch from the lsb/master based branch with the same commit"
    else
      echo "Branch does not end with a -rel-x.y* pattern. Please check and run manually"
      return
    fi
  fi

  if string.isemptyorblank $1
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetoreleasethenmaster $reviewrequestid
    fi
  else
    reviewrequestid=$1
    # Merge to release first

    rebaselatestbranch $CURRENT_RELEASE
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to release, otherwise press Ctrl+C and do it manually"
    git checkout $CURRENT_RELEASE
    mergepush $currentbranch -r $reviewrequestid

    # Merge changes back to master
    waitforenterkey "Merging changes to master now, press enter when ready"
    checkoutfrommaster $currentbranch

    #Rename the current branch before reassigning
    markbranchmerged $currentbranch

    currentbranch=$(git.getcurrentbranch)
    git merge $CURRENT_RELEASE

    # Validate that only your commits are included. If you see more than your changes here, wait for other authors to push  theirs, do pullmerge master after that or ask them if it is OK to push the changes to master.
    git log --format="%an: %s" master..$currentbranch

    waitforenterkey "Press enter if you see only your commits above, otherwise press Ctrl+C and do it manually"

    git checkout master
    mergepush $currentbranch -r $reviewrequestid --no-resolve # don't resolve the bug again, so fixed-in hash keeps pointing to the rel branch

    git checkout $currentbranch
    markbranchmerged $currentbranch
  fi
}

function startDockerApp() {
  if ! system.commandsucceeds $(open -a /Applications/Docker.app)
  then
    echo "Can't open Docker app"
    return
  else
    # Give Docker some time to get ready
    sleep 5
  fi
}

# Start required services for the Onshape server
# and newton to run (not the server itself, use
# startservers for that). Also starts Docker
# is not already running.
function startServices() {
  if ! (system.isprocessrunning "docker")
  then
    echo "Starting Docker process as it was not found to be running"
    startDockerApp
  else
    echo "Docker found to be running"
  fi
  # Actually start the services now when Docker is confirmed to be running
  btEnvUp
}

# Starts both the Onshape (belcad) server
# and calls grunt quickServe to
function startservers() {
  if ! (system.isprocessrunning "docker")
  then
    # startServices is supposed to start
    # Docker as well if not running
    startServices
  fi
  startbelcad
  grunt quickServe
}

function stopservers() {
  fstopbelcad "nosleep"
  fstopquickserve
}

function restartservers() {
  stopservers
  startservers
}

function buildall() {
  cd $REPO_NEWTON
  buildgradleparallel
}

function buildjavaonly() {
    export SKIP_CPP=1
    export SKIP_JSLIB=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JSLIB
}

function buildjsonly() {
    export SKIP_DRAWING=1
    export SKIP_CPP=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JAVA
}

function buildcpponly() {
    export SKIP_JSLIB=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_JSLIB
    unset SKIP_JAVA
}

function buildjavaandjsonly() {
    export SKIP_CPP=1
    buildgradleparallel
    unset SKIP_CPP
}

function ptortest() {
 ptor $1 --verbose --flags=fastFail --target=http://localhost.onshape.io:8000/
}

function pushtos3() {
  # Put a timestamp to the branch name and remove hyphen after bel from branch name
  # as otherwise kibana logs show the branch name only as "bel" and nothing else
  local originalbranchname=$(git.getcurrentbranch)
  local currentdatetime=$(system.getcurrentdate "_")

  # Change bel-xxxxxx to bel_xxxxxx
  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  local newbranchname=$(echo $originalbranchname | sed -En "s,bel-([[:digit:]]+),bel_\1_$currentdatetime,p")
  # Change just a couple of hyphens to underscore for more info of the branch name to show up in elastic search
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  #echo $originalbranchname
  #echo $newbranchname
  git.renamecurrentbranch $newbranchname
  pushToBuildFarm @promote-to-s3-test
  # After it's done, change the branch name back to original
  git.renamecurrentbranch $originalbranchname
}

# Function for visualizing timer.log times. Call this followed by opening
# localhost:8088 page in the browser. Visit https://github.com/onshape/timerdisplay
# for more details
function runTimerDisplay() {
  cd $HOME/repos/timerdisplay
  sleep 5 && open "http://localhost:8088" & # Delay launch the webpage :).
  ./server.js -p 8088 $STAGE/WebSvc/logs/timer.log --debug
}

# Remove from work (Better suited for personal profile)?
# Quickly create or update a dummy branch that's based on latest
# lsb/master. For those non-ideal times you need lsb/master as a branch
# and not as a tag.
function updatedummylsbmaster() {
  # Store current branch
  local currentbranch=$(git.getcurrentbranch)
  local dummybranchname=$(getnewbranchname "dummy" "lsb/master")
  local alreadyindummybranch="false"
  if git.localbranchexists $dummybranchname
  then
      if ! string.equals $currentbranch $dummybranchname
      then
        git checkout "$dummybranchname"
      fi
      pulllatest
  else
    echo "Updating $dummybranchname with latest lsb/master"
    checkoutfromlsbmaster "dummy"
  fi

  if ! string.equals $currentbranch $dummybranchname
  then
    echo "Checking out previous branch again"
    git checkout $currentbranch
  fi
}

alias bfnodestop='bf job rm'
alias bfjobremove='bfnodestop'
alias bsserverpath="$STAGE/BSServer/bin/BSServer"
alias grdlbuildjavaonly='grdlu gen java' #Build java only, download binaries for others
alias grdlbuildjsonly='grdlu gen js' #Build javascript only, download binaries for others
alias grdlbuildjavaandjsonly='grdlu gen java js' #Build java and javascript only, download binaries for others
alias checkJsCode='grunt checkJsCode'
alias checkjs='grunt eslint:javascript'
alias checkts='grunt eslint:typescript'
# alias clion="open -a $HOME/Applications/JetBrains\ Toolbox/CLion.app"
alias cppbuild='buildcpponly'
alias droptoproduction='mongoDropToProduction'
alias eclipse='open -a /Applications/Eclipse.app'
alias eslintfix='grunt eslint:fix'
alias fixgruntnotfound='fixDiskImagesJS'
alias fixjs='grunt eslint:fix'
alias fixts='grunt eslint:fix'
alias fixpo='grunt xgettext --fix'
alias generateserializables='grunt generateSerializables'
alias genser='grunt generateSerializables'
alias gitlistskipignoredfiles='git ls-files -v . | grep ^S'
alias gruntQuickServe='grunt quickServe'
alias inteli='intellij'
alias intellij='idea' #Jetbrains Toolbox generates the script 'idea' for version dependent IntelliJ IDEA
alias javabuild='buildjavaonly'
alias jsbuild='buildjsonly'
alias jumpboxaddstaticroute='addstaticroutetojumpbox'
alias jumpboxnetstat='netstat -rn | grep 52.210.113.201'
alias jumpboxssh='sshjumpbox'
alias localprecommit='yarn precommit'
alias lsbreleasecheckout='checkoutfromlsbrelease'
# alias mergelatestmaster='pullmerge master'
alias mongodump='mongoDump'
alias mongobackup='mongoDump'
alias mongorestore='mongoRestore'
alias backupmongo='mongoDump'
alias restoremongo='mongoRestore'
alias newton='cd $REPO_NEWTON'
alias kibanatools='cd $DEV_TOOLS/kibanaTools'
alias pofix='fixpo'
alias prepeclipse='gradle prepEclipse'
alias prepclion='gradle :cpp:prepCLion --parallel'
alias protractortest='ptortest'
alias runprotractortest='ptortest'
alias runptortest='ptortest'
# alias pullmaster='pullmerge master'
# alias pullmergemaster='pullmerge master'
alias pushtobuild='pushToBuildFarm @precommit @uitest @mocha'
alias quickserve='grunt quickServe'
# alias rebasemaster='pullmerge master --rebase'
alias serial='grunt generateSerializables'
alias serialize='grunt generateSerializables'
alias sshjumpbox="ssh -X $USER@jumpbox-primary.dev.onshape.com"
alias startenv='startServices;startservers';
alias starttimerdisplay='runTimerDisplay'
alias stopServices='btEnvDown'
alias startallservers='startservers'
alias restartServices='stopServices;startServices'
alias startfrontend='grunt quickServe'
alias timerdisplay='runTimerDisplay'
alias updaterbt='rbtupdate'
alias xcode='open -a Xcode.app $STAGE/build/cppServer/DebugXcodeCCache/BTcppServer.xcodeproj/'
alias web='webstorm'
alias webs='webstorm'
alias storm='webstorm'
alias productionretrievalconfigfile='$STAGE/ModelingSvc/webapps/root/WEB-INF/config/applicationContext.xml'
alias openbtserver='openbtserverweblog'
alias isbelcadrunning='isonshapeserverrunning'
alias opentimerlog='opentimerlogweb'
