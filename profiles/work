# Official exports:
export USE_CCACHE=1 #cpp compiler cache
export RELEASE=0 #debug cpp build
export BTI_ENABLE_TIMERS=1 #measure load times in viewer
export BTI_DISABLE_HEARTBEATS=1 #So that BSServer doesn't time out so early
export BTI_BLOCK_THUMBNAIL_CPP_SERVER_POOL=1 #if debugging, cut down on the number of BSServers available to attach to
export DEV_TOOLS=/Users/$USER/repos/onshape-dev-tools
export BASH_SILENCE_DEPRECATION_WARNING=1
#export OBJECT_STORE_REPO_REGION=ap-south-1 #improve artifactory download performance from S3. 
#export HOST_PROPERTIES_PRIVATEIP="$(dockerCreateLoopbackAlias)"

# This is only an issue if you usually extract std from stacks and upgrade has to process lot of std versions
# In that case, there might be out of memory problems while building java
export UPGRADE_MAX_MEMORY_GB=8
export JAVA_MAX_MEMORY_MB=8192

# Unofficial exports:
export CURRENT_RELEASE=rel-1.153
export LSB_MASTER=lsb/master
export LSB_CURRENT_RELEASE=lsb/$CURRENT_RELEASE
export GIT_MERGE_AUTOEDIT=no
export RETRIEVAL_REPORT_WRITE_TO_DISK=1
export PATH="/Users/$USER/Library/Python/3.8/bin:${PATH}"


# Newton Startup
cd ~/repos/newton
source buildenv.bash


# Import Utility modules
importutility string
importutility system
importutility git
importutility rbt


# Set CPP builder according to the platform
function platformspecificsettings() {
  if system.ismacos
  then
    echo "Detected macOS, using XCODEBUILD"
    unset CLIONBUILD
    export XCODEBUILD=1
  else # Assume Linux for now.
    echo "Using CLIONBUILD for building C++"
    unset XCODEBUILD
    export CLIONBUILD=1
  fi
}

# Make a call to it here itself
platformspecificsettings

function setrelease() {
  if string.equals $1 "0"
  then
    export RELEASE=0
    echo "Set to build in debug mode"
  else #empty or any other argument.
    export RELEASE=1
    echo "Set to build in release mode"
  fi
}

function setdebug() {
  if string.equals $1 "0"
  then
    export RELEASE=1
    echo "Set to build in release mode"
  else #empty or any other argument.
    export RELEASE=0
    echo "Set to build in debug mode"
  fi
}

function debugstaging() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://staging.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugdemoc() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://demo-c.dev.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function debugproduction() {
  #Try to debug staging
  export PROXY_TARGET_HOST='https://cad.onshape.com'
  unset HOST_PROPERTIES_PRIVATEIP
  unset HOST_PROPERTIES_HOSTNAME
  echo "REMEMBER TO CLOSE THE TERMINAL AFTER THIS SESSION, OR CALLING source buildenv.bash AGAIN WHEN YOU'RE DONE"
  grunt quickServe
}

function fixDiskImagesJS() {
  diskImageUmountAll
  rm ~/build_tools/diskimage/onshape-javascript_*
  source buildenv.bash
}

function importextractedfile() {
  echo Sending argument: "$1"
  restoreDump "$1" --nodrop --remap=btadmin@onshape.com
}

function runupgrade() {
  gradle runDocumentUpgrade -Donshape.upgrade.exitwhenfinished=true
}

function runretrieval() {
  if string.isemptyorblank $1
  then
    echo "A numeric Jenkins build id is required"
    return
  fi

  # If there's a second argument specified, take it as the documentidregex string
  # input to the retrieval service (which you should ideally pass without spaces,
  # as I haven't tested what will happen with spaces in these arguments :) )
  if string.isemptyorblank $2
  then
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1
  else
    gradle runProductionRetrieval -Donshape.productionretrieval.local=true -Donshape.productionretrieval.exitwhenfinished=true -Donshape.productionretrieval.jenkinsbuildid=$1 -Donshape.productionretrieval.documentidregex=$2
  fi
}

function makelikeproduction() {
  #Make sure Docker is running, and mongo service is running as well
  mongobackup
  stopbelcad
  mongoDropAll
  mongoDropToProduction
  export SKIP_INTERNAL_MODULES=1
}

function makelikeproductionwithbuild() {
  makelikeproduction
  buildgradleparallel
}

function openconfigpropertiesjson() {
  texteditor $REPO_NEWTON/project/web/WEB-INF/config/config-properties.json
}

function setupforproductionretrieval() {
  # First make your environment 'like' production (though that might not be necessary to just 'run' and debug the code)
  #makelikeproduction
  echo "setting SKIP_INTERNAL_MODULES to 1"
  export SKIP_INTERNAL_MODULES=1
  openconfigpropertiesjson
  echo "Change the defaultValue of productionretrieval.write-s3 from false to true in the opened config-properties.json"
  waitforenterkey "Press enter when done"
  echo "Build (gradle) manually now using buildgradleparallel"
  #buildgradleparallel
  #waitforenterkey "Press enter when done"
  echo "call runupgrade to run document upgrade"
  #runupgrade
  #waitforenterkey "Press enter when upgrade has been done"
  echo "You can now see upgrade logs in $STAGE/ModelingSvc/logs/btserver.log"
  echo "Also, the upgrade data should be written to $STAGE/MockS3/onshape-myregion/test/operations/myenv/regen-data"
  #open "$STAGE/MockS3/onshape-us-east-1/test/operations/myenv/regen-data"
  echo "Finally, run the local production retrieval process by calling runretrieval"
  #runretrieval
}

function waitforenterkey() {
  read -p "$1"
}

function runjunittest() {
    gradle safelyRunSpecificTests -Dtest=$1
}

function awsconfigure() {
  btAws configure --profile codebuild
}

function myprecommit() {
  # Remove this first line once yarn precommit starts catching
  # typescript errors again
  #npx tsc --noEmit --project $REPO_NEWTON/project/web/tsconfig.json
  checkTidy
  gradle :java:pmd
  #gradle :java:codeChecker
  grunt checkJsCode
}

function addstaticroutetojumpbox() {
  sudo route -n add 54.187.217.158/32 $1
}

function getnewbranchname() {
  inputbranchname=$(string.tolower $1)
  targetbranch=$(string.tolower $2)
  if ! (string.beginswith $inputbranchname "$USER/")
  then
    inputbranchname=$USER/$inputbranchname
  fi

  # Remove all lsb-release, lsb-master, -master, rel- etc. suffixes from the branch  name
  inputbranchname=$(string.simplereplace $inputbranchname "-lsb-*" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-master" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-release" "")
  inputbranchname=$(string.simplereplace $inputbranchname "-rel-[1-9]*" "")
  if string.isnotemptyorblank $targetbranch
  then
    targetbranch=$(string.simplereplace $targetbranch "/" "-")
    inputbranchname=$inputbranchname-$targetbranch
  fi

  echo $inputbranchname
}

function checkoutfromlatestmaster() {
  git checkout master
  git pull
  git checkout -b $(getnewbranchname $1 "master")
}

function checkoutfromrelease() {
  git checkout $CURRENT_RELEASE
  git pull
  git checkout -b $(getnewbranchname $1 $CURRENT_RELEASE)
}

function checkoutfromlsbbranch() {
  if string.isemptyorblank $1
  then
    echo "Please provide new branch name"
  elif string.isemptyorblank $2
  then
    echo "Please provide the base branch name"
  else
    gitBranchLsb $(getnewbranchname $1 "lsb/$2") $2
  fi
}

function checkoutfromlsbmaster() {
  checkoutfromlsbbranch "$1" "master" #lsb/ is eventually appended by gitBranchLsb
}

function checkoutfromlsbrelease() {
  checkoutfromlsbbranch "$1" "$CURRENT_RELEASE" #lsb/ is eventually appended by gitBranchLsb
}

# Unless otherwise specified, default branch for rbt is master
function rebaselatest() {
  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Rebasing w.r.t. to that"
    rebaselatestbranch $LSB_MASTER
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Rebasing w.r.t. to that"
    rebaselatestbranch $LSB_CURRENT_RELEASE
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Rebasing w.r.t. to that"
    rebaselatestbranch master
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Rebasing w.r.t. to that"
    rebaselatestbranch $CURRENT_RELEASE
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based rebase"
    rebaselatestbranch master
  fi
}

function rebaselatestbranch() {
  pullmerge $1 --rebase
}

# function rebaselatestmaster() {
#   pullmerge master --rebase
# }

# function rebaselatestlsbmaster() {
#   pullmerge $LSB_MASTER --rebase
# }

# function rebaselatestlsbrelease() {
#   pullmerge $LSB_CURRENT_RELEASE --rebase
# }

# function rebaselatestrelease() {
#   pullmerge $CURRENT_RELEASE --rebase
# }

function pulllatestlsbrelease() {
  pullmerge $LSB_CURRENT_RELEASE
}

function pulllatestrelease() {
  pullmerge $CURRENT_RELEASE
}

# Unless otherwise specified, default branch for rbt is master
function rbtupdate() {
  if git.branchislsbmasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefromlsbmaster
  elif git.branchislsbreleasebased
  then
    echo "Detected lsb/rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefromlsbrelease
  elif git.branchismasterbased
  then
    echo "Detected lsb/master based branch. Creating diff w.r.t. to that"
    rbtupdatefrommaster
  elif git.branchisreleasebased
  then
  echo "Detected rel-* based branch. Creating diff w.r.t. to that"
    rbtupdatefromrelease
  else
    echo "Didn't detect standard (lsb/)master/release based branches, defaulting to master based diff"
    rbtupdatefrommaster
  fi
}

function rbtupdatewithrebase() {
  rebaselatestmaster
  rbtupdate
}

function testregex() {

  var1='rel-1'
  var2='rel-[0-9]*'
  if [[ 'rel-1' =~ 'rel-[0-9]*' ]]
  then
    echo yes
  else
    echo no
  fi


  check_dec='^rel-[0-9]\.[0-9]+'
  input=0

  echo "Please enter a digit: "
  read input

  if [[ $input =~ $check_dec ]]
  then
           echo "The value is a decimal"
  else
          echo "The value is something else"
  fi
}

function rbtpost() {
  rbt post -o
}

function rbtpostwithrebase() {
  rebaselatestmaster
  rbtpost
}

function rbtpostfromlsbmaster() {
  echo "Calling rbt post -o $LSB_MASTER...HEAD"
  rbt post -o $LSB_MASTER...HEAD
}

function rbtpostfromlsbrelease() {
  echo "Calling rbt post -o $LSB_CURRENT_RELEASE...HEAD"
  rbt post -o $LSB_CURRENT_RELEASE...HEAD
}


function rbtupdatefrombranch() {
  if string.isemptyorblank $1
  then
    echo "Please give the branch name"
  elif string.isemptyorblank $2
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_ANY)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find a matching review request for the branch, enter manually."
    else
      echo "Automatically found review request id: $reviewrequestid for current branch"
      rbtupdatefrombranch $1 $reviewrequestid
    fi
  else
    echo "Calling rbt post -o -u -r $2 $1...HEAD"
    rbt post -o -u -r $2 $1...HEAD
  fi
}

function rbtupdatefromlsbrelease() {
  rbtupdatefrombranch $LSB_CURRENT_RELEASE $1
}

function rbtupdatefromlsbmaster() {
  rbtupdatefrombranch $LSB_MASTER $1
}

function rbtupdatefrommaster() {
  rbtupdatefrombranch "master" $1
}

function rbtupdatefromrelease() {
  rbtupdatefrombranch $CURRENT_RELEASE $1
}


function rbtpostfromlsbreleasewithrebase() {
  rebaselatestlsbrelease
  rbtpostfromlsbrelease "$@"
}

function rbtpostfromlsbmasterwithrebase() {
  rebaselatestlsbmaster
  rbtpostfromlsbmaster "$@"
}

function rbtupdatefromlsbreleasewithrebase() {
  rebaselatestlsbrelease
  rbtupdatefromlsbrelease "$@"
}

function rbtupdatefromlsbmasterwithrebase() {
  rebaselatestlsbmaster
  rbtupdatefromlsbmaster "$@"
}

function setupjumpboxcertificates() {
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.key /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:$USER.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:ca.crt /tmp
  scp $USERNAME@jumpbox-primary.dev.onshape.com:tls-auth.key /tmp
}

function fstopbelcad() {
  # Consider using this instead, which is multi-env aware: checkServices -s websvc
  local jettypid=$(ps -ef | grep jetty | grep -v grep | awk '{print $2}')
  if string.isemptyorblank $jettypid
  then
    echo "Didn't find jetty process to kill"
    # echo "Didn't find jetty process, falling back to standard stopbelcad"
    #stopbelcad
  else
    echo "Killing PID $jettypid"
    kill -9 $jettypid
  fi
}

function restartbelcad() {
  fstopbelcad
  startbelcad
}

function beep() {
  tput bel
}

function playfinishsound() {
  beep;beep;
  if string.isemptyorblank $1
  then
    say "Build Complete"
  else
    say "$1"
  fi
}

function buildgradleparallel() {
  if ! system.isprocessrunning "Docker"
  then
    echo "Docker is not running, please start it and try again."
    return
  fi

  gradle --parallel
  if [ $? -eq 0 ] # last command was successful
  then
    playfinishsound "Build successful"
  else
    playfinishsound "Build failed"
  fi
}

# There's no reason to keep merged branches
# but we can keep for a few days just for reference purposes
function markbranchmerged() {
  git.renamebranch $1 $1-merged
}

function createlsbreleasebranchfromlsbmastertopchange() {
  if ! git.branchislsbmasterbased
  then
    echo "It's not an lsb/master based branch. Please check the branch name again."
    return
  fi

  topSHAId=$(git.getlatestcommitid)
  currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbrelease $(getnewbranchname $currentbranch $LSB_CURRENT_RELEASE)
  git cherry-pick $topSHAId
}

function createlsbmasterbranchfromlsbreleasetopchange() {
  if ! git.branchislsbreleasebased
  then
    echo "It's not an lsb/release based branch. Please check the branch name again."
    return
  fi
  topSHAId=$(git.getlatestcommitid)
  currentbranch=$(git.getcurrentbranch)
  checkoutfromlsbmaster $(getnewbranchname $currentbranch $LSB_MASTER)
  git cherry-pick $topSHAId
}

function mergetomaster() {
  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to master"
    return
  fi

  if ! git.branchislsbmasterbased && ! git.branchismasterbased
  then
    echo "Branch is not lsb/master or master based. Please check and try again"
    return
  fi

  # Check if a specific rbcommons review request id is given
  # Search for an approved request for the current git branch if not.
  if string.isemptyorblank $1
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetomaster $reviewrequestid
    fi
  else
    currentbranch=$(git.getcurrentbranch)
    rebaselatestmaster
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to master"
    git checkout master
    echo "calling mergepush $currentbranch -r $1"
    mergepush $currentbranch -r $1
    git checkout $currentbranch
    # rename the current branch as 'merged' to keep for a few days
    markbranchmerged $currentbranch
  fi
}

function mergetoreleasethenmaster() {
  if git.hasUncommittedChanges
  then
    echo "There are uncommitted changes. Please fix before merging to release"
    return
  fi

  local currentbranch=$(git.getcurrentbranch)

  if ! (string.endswith $currentbranch "-rel-[0-9].[0-9]*")
  then
    if git.branchislsbmasterbased
    then
      # Try automatically creating lsb/release based branch of it with the top commit.
      git log -n 3
      waitforenterkey "lsb/master based branch found. Press enter if all of your changes are in one top commit, and ready to create lsb/release branch off it (Otherwise press Ctrl+C and try again later)."
      createlsbreleasebranchfromlsbmastertopchange
      waitforenterkey "Press enter if the lsb/release branch creation was successful, otherwise press Ctrl+C and try again later."
      currentbranch=$(git.getcurrentbranch)
      echo "Created branch $currentbranch from the lsb/master based branch with the same commit"
    else
      echo "Branch does not end with a -rel-x.y* pattern. Please check and run manually"
      return
    fi
  fi

  if string.isemptyorblank $1
  then
    reviewrequestid=$(rbt.getcurrentid $REVIEW_STATUS_APPROVED)
    if string.isemptyorblank $reviewrequestid
    then
      echo "Didn't find an approved review request for the branch, enter manually."
    else
      echo "Automatically found approved review request id: $reviewrequestid for current branch, merging with the same"
      mergetoreleasethenmaster $reviewrequestid
    fi
  else
    reviewrequestid=$1
    # Merge to release first

    rebaselatestrelease
    waitforenterkey "Press enter if and when rebase is successful to continue to merge to release, otherwise press Ctrl+C and do it manually"
    git checkout $CURRENT_RELEASE
    mergepush $currentbranch -r $reviewrequestid

    # Merge changes back to master
    waitforenterkey "Merging changes to master now, press enter when ready"
    checkoutfromlatestmaster $currentbranch

    #Rename the current branch before reassigning
    markbranchmerged $currentbranch

    currentbranch=$(git.getcurrentbranch)
    git merge $CURRENT_RELEASE

    # Validate that only your commits are included. If you see more than your changes here, wait for other authors to push  theirs, do pullmerge master after that or ask them if it is OK to push the changes to master.
    git log --format="%an: %s" master..$currentbranch

    waitforenterkey "Press enter if you see only your commits above, otherwise press Ctrl+C and do it manually"

    git checkout master
    mergepush $currentbranch -r $reviewrequestid --no-resolve # don't resolve the bug again, so fixed-in hash keeps pointing to the rel branch

    git checkout $currentbranch
    markbranchmerged $currentbranch
  fi
}

function startDockerApp() {
  if ! system.commandsucceeds $(open -a /Applications/Docker.app)
  then
    echo "Can't open Docker app"
    return
  else
    # Give Docker some time to get ready
    sleep 5
  fi
}

function startServices() {
  if ! (system.isprocessrunning "docker")
  then
    echo "Starting Docker process as it was not found to be running"
    startDockerApp
  else
    echo "Docker found to be running"
  fi
  # Actually start the services now when Docker is confirmed to be running
  btEnvUp
}

function startservers() {
    startbelcad
    grunt quickServe
}

function buildall() {
  cd $REPO_NEWTON
  buildgradleparallel
}

function buildjavaonly() {
    export SKIP_CPP=1
    export SKIP_JSLIB=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JSLIB
}

function buildjsonly() {
    export SKIP_CPP=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_CPP
    unset SKIP_JAVA
}

function buildcpponly() {
    export SKIP_JSLIB=1
    export SKIP_JAVA=1
    buildgradleparallel
    unset SKIP_JSLIB
    unset SKIP_JAVA
}

function buildjavaandjsonly() {
    export SKIP_CPP=1
    buildgradleparallel
    unset SKIP_CPP
}

function ptortest() {
 ptor $1 --verbose --flags=fastFail --target=http://localhost.onshape.io:8000/
}

function pushtos3() {
  # Put a timestamp to the branch name and remove hyphen after bel from branch name
  # as otherwise kibana logs show the branch name only as "bel" and nothing else
  local originalbranchname=$(git.getcurrentbranch)
  local currentdatetime=$(system.getcurrentdate "_")

  # Change bel-xxxxxx to bel_xxxxxx
  # sed syntax : "s,search_string,replace_string,regex_flags" (most other characters allowed as separator instead of ,)
  local newbranchname=$(echo $originalbranchname | sed -En "s,bel-([[:digit:]]+),bel_\1_$currentdatetime,p")
  # Change just a couple of hyphens to underscore for more info of the branch name to show up in elastic search
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  newbranchname=$(string.replacefirstoccurrence $newbranchname '-' '_')
  #echo $originalbranchname
  #echo $newbranchname
  git.renamecurrentbranch $newbranchname
  pushToBuildFarm @promote-to-s3-test
  # After it's done, change the branch name back to original
  git.renamecurrentbranch $originalbranchname
}

# Function for visualizing timer.log times. Call this followed by opening
# localhost:8088 page in the browser. Visit https://github.com/onshape/timerdisplay
# for more details
function runTimerDisplay() {
  cd ~/repos/timerdisplay
  open "http://localhost:8088"
  ./server.js -p 8088 ~/stage/WebSvc/logs/timer.log --debug
}

alias bfnodestop='bf job rm'
alias bfjobremove='bfnodestop'
alias bsserverpath="/Users/$USER/stage/BSServer/bin/BSServer"
alias grdlbuildjavaonly='grdlu gen java' #Build java only, download binaries for others
alias grdlbuildjsonly='grdlu gen js' #Build javascript only, download binaries for others
alias grdlbuildjavaandjsonly='grdlu gen java js' #Build java and javascript only, download binaries for others
alias checkJsCode='grunt checkJsCode'
alias checkjs='grunt eslint:javascript'
alias checkts='grunt eslint:typescript'
# alias clion="open -a /Users/$USER/Applications/JetBrains\ Toolbox/CLion.app"
alias cppbuild='buildcpponly'
alias droptoproduction='mongoDropToProduction'
alias eclipse='open -a /Applications/Eclipse.app'
alias eslintfix='grunt eslint:fix'
alias fixgruntnotfound='fixDiskImagesJS'
alias fixjs='grunt eslint:fix'
alias fixts='grunt eslint:fix'
alias fixpo='grunt xgettext --fix'
alias generateserializables='grunt generateSerializables'
alias genser='grunt generateSerializables'
alias gitlistskipignoredfiles='git ls-files -v . | grep ^S'
alias gruntQuickServe='grunt quickServe'
alias inteli='intellij'
alias intellij='idea' #Jetbrains Toolbox generates the script 'idea' for version dependent IntelliJ IDEA
alias javabuild='buildjavaonly'
alias jsbuild='buildjsonly'
alias jumpboxaddstaticroute='addstaticroutetojumpbox'
alias jumpboxnetstat='netstat -rn | grep 52.210.113.201'
alias jumpboxssh='sshjumpbox'
alias localprecommit='yarn precommit'
alias lsbreleasecheckout='checkoutfromlsbrelease'
alias lsbreleaserebaselatest='rebaselatestlsbrelease'
alias lsbreleasepulllatest='pulllatestlsbrelease'
alias lsbreleaserbtupdate='rbtupdatefromlsbrelease'
alias lsbreleaserbtpost='rbtpostfromlsbrelease'
alias mergelatestmaster='pullmerge master'
alias mongodump='mongoDump'
alias mongobackup='mongoDump'
alias mongorestore='mongoRestore'
alias backupmongo='mongoDump'
alias restoremongo='mongoRestore'
alias newton='cd $REPO_NEWTON'
alias kibanatools='cd $DEV_TOOLS/kibanaTools'
alias pofix='fixpo'
alias prepeclipse='gradle prepEclipse'
alias prepclion='gradle :cpp:prepCLion --parallel'
alias protractortest='ptortest'
alias runprotractortest='ptortest'
alias runptortest='ptortest'
alias pulllatestmaster='pullmerge master'
alias pulllatestlsbmaster='pullmerge $LSB_MASTER'
alias pullmaster='pullmerge master'
alias pullmergemaster='pullmerge master'
alias pushtobuild='pushToBuildFarm @precommit @uitest @mocha'
alias quickserve='grunt quickServe'
alias rebasemaster='pullmerge master --rebase'
alias serial='grunt generateSerializables'
alias serialize='grunt generateSerializables'
alias sshjumpbox="ssh -X $USER@jumpbox-primary.dev.onshape.com"
alias startenv='startServices;startservers';
alias starttimerdisplay='runTimerDisplay'
alias stopServices='btEnvDown'
alias startallservers='startservers'
alias restartServices='stopServices;startServices'
alias startfrontend='grunt quickServe'
alias timerdisplay='runTimerDisplay'
alias updaterbt='rbtupdate'
alias xcode='open -a Xcode.app $STAGE/build/cppServer/DebugXcodeCCache/BTcppServer.xcodeproj/'
alias web='webstorm'
alias webs='webstorm'
alias storm='webstorm'
alias productionretrievalconfigfile='$STAGE/ModelingSvc/webapps/root/WEB-INF/config/applicationContext.xml'
